<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8K Stock Market Candlestick Chart with Cluster Analysis</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0c0c0c, #1a1a2e, #16213e);
            color: white;
            overflow-x: auto;
        }
        
        .container {
            width: 100%;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .overlay-left {
                top: 60px;
                bottom: 20px;
                right: 20px;
                left: 20px;
                max-width: none;
                flex-direction: column;
                gap: 10px;
            }
            
            .overlay-panel {
                min-width: 150px;
                max-width: none;
                padding: 10px 12px;
            }
            
            .overlay-stats {
                grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
                gap: 6px;
            }
            
            .overlay-legend {
                max-height: 150px;
            }
            
            .settings-container {
                margin-bottom: 15px;
            }
            
            .overlay-settings-panel {
                left: 10px;
                right: 10px;
                min-width: auto;
            }
            
            .overlay-panel-header {
                padding: 4px 0;
            }
            
            .overlay-panel-btn {
                padding: 2px 4px;
                font-size: 8px;
            }
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        h1 {
            font-size: 3rem;
            margin: 0;
            background: linear-gradient(45deg, #00ff88, #00d4ff, #ff6b6b);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            margin-top: 10px;
        }

        .data-input {
            background: rgba(255, 255, 255, 0.08);
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
        }
        
        .data-input h3 {
            margin: 0 0 15px 0;
            font-size: 18px;
            font-weight: 600;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .data-input textarea {
            width: 100%;
            height: 150px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            color: white;
            font-family: monospace;
            resize: vertical;
            box-sizing: border-box;
        }

        .data-buttons {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(45deg, #00ff88, #00d4ff);
            color: #000;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        
        .controls {
            display: none; /* Hidden - using overlay controls instead */
        }
        
        .control-section {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
        }
        
        .control-section h3 {
            margin: 0 0 18px 0;
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .control-group {
            margin-bottom: 16px;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.9);
        }
        
        select, input {
            width: 100%;
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 8px;
            padding: 10px 12px;
            color: white;
            font-size: 14px;
            box-sizing: border-box;
            transition: all 0.2s ease;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 0 2px rgba(0, 255, 136, 0.2);
        }
        
        select option {
            background: #1a1a2e;
            color: white;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 16px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin: 0;
            accent-color: #00ff88;
        }
        
        .checkbox-group label {
            margin: 0;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
        }
        
        .legend {
            display: none; /* Hidden - using overlay legend instead */
        }
        
        .legend h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .legend-content {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.08);
            padding: 10px 16px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 0.2s ease;
        }
        
        .legend-item:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-1px);
        }
        
        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .chart-container {
            width: 100%;
            height: 80vh;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            box-sizing: border-box;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .chart-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }
        
        .chart-overlay > * {
            pointer-events: auto;
        }
        
        .overlay-top {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 20px;
        }
        
        .overlay-bottom {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            gap: 20px;
        }
        
        .overlay-left {
            position: absolute;
            top: 20px;
            left: 20px;
            bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-width: 320px;
        }
        
        .overlay-right {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .overlay-panel {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px 16px;
            min-width: 200px;
            max-width: 300px;
            transition: all 0.3s ease;
        }
        
        .overlay-panel.minimized {
            padding: 8px 12px;
            min-width: 120px;
            max-width: 150px;
        }
        
        .overlay-panel.minimized .overlay-controls,
        .overlay-panel.minimized .overlay-stats,
        .overlay-panel.minimized .overlay-legend {
            display: none;
        }
        
        .overlay-panel.minimized h4 {
            margin-bottom: 0;
            font-size: 12px;
        }
        
        .overlay-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
        }
        
        .overlay-panel-header h4 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .overlay-panel-controls {
            display: flex;
            gap: 4px;
        }
        
        .overlay-panel-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 4px 6px;
            color: white;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .overlay-panel-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #00ff88;
        }
        
        .settings-container {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 20px;
            position: relative;
        }
        
        .overlay-settings {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 8px 12px;
            color: white;
            font-size: 12px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s ease;
            z-index: 20;
        }
        
        .overlay-settings:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: #00ff88;
        }
        
        .overlay-settings-panel {
            position: absolute;
            top: 40px;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            backdrop-filter: blur(10px);
            z-index: 25;
            min-width: 200px;
        }
        
        .overlay-settings-panel.hidden {
            display: none;
        }
        
        .overlay-settings-group {
            margin-bottom: 12px;
        }
        
        .overlay-settings-group:last-child {
            margin-bottom: 0;
        }
        
        .overlay-settings-group label {
            display: block;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .overlay-settings-group input[type="range"] {
            width: 100%;
            margin-bottom: 4px;
        }
        
        .overlay-settings-group input[type="checkbox"] {
            margin-right: 6px;
            accent-color: #00ff88;
        }
        
        .overlay-settings-group .panel-visibility-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 4px;
        }
        
        .overlay-settings-group .panel-checkbox {
            font-size: 10px;
            display: flex;
            align-items: center;
            padding: 2px 0;
        }
        
        .overlay-settings-group .panel-checkbox input[type="checkbox"] {
            margin-right: 4px;
            width: 12px;
            height: 12px;
        }
        
        .overlay-settings-value {
            font-size: 10px;
            color: #00ff88;
            text-align: center;
        }
        
        .overlay-panel h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 6px;
        }
        
        .overlay-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .overlay-control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .overlay-control-group label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
        }
        
        .overlay-control-group select,
        .overlay-control-group input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 6px 8px;
            color: white;
            font-size: 12px;
        }
        
        .overlay-control-group select:focus,
        .overlay-control-group input:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 0 1px rgba(0, 255, 136, 0.3);
        }
        
        .overlay-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 8px;
        }
        
        .overlay-stat-item {
            text-align: center;
            padding: 6px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .overlay-stat-value {
            font-size: 16px;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 2px;
        }
        
        .overlay-stat-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .overlay-legend {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .overlay-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            font-size: 11px;
        }
        
        .overlay-legend-color {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        
        .overlay-hidden {
            display: none;
        }
        
        #candlestickChart {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            cursor: crosshair;
        }
        
        #candlestickChart:active {
            cursor: grabbing;
        }
        
        .stats {
            display: none; /* Hidden - using overlay stats instead */
        }
        
        .stats h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stats-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.08);
            padding: 18px 16px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            text-align: center;
            transition: all 0.2s ease;
        }
        
        .stat-card:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-2px);
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 6px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .stat-label {
            font-size: 0.85rem;
            opacity: 0.9;
            font-weight: 500;
            margin-top: 5px;
        }

        .error {
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid rgba(255, 107, 107, 0.5);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .success {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid rgba(0, 255, 136, 0.5);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📈 8K Stock Market Candlestick Analysis</h1>
            <div class="subtitle">Interactive Hourly Data with ML Cluster Classification</div>
        </div>

        <div class="data-input">
            <h3>📊 Data Input</h3>
            <p>Paste your CSV data below (with headers: timestamp,open,high,low,close,volume,predicted_cluster) or use sample data:</p>
            <textarea id="csvInput" placeholder="timestamp,open,high,low,close,volume,predicted_cluster
2024-09-06T09:00:00Z,520.50,525.00,519.00,523.75,1250000,0
2024-09-06T10:00:00Z,523.75,526.50,521.00,524.25,980000,1
..."></textarea>
            <div class="data-buttons">
                <button class="btn btn-primary" onclick="loadCSVData()">📈 Load CSV Data</button>
                <button class="btn btn-secondary" onclick="generateSampleData()">🎲 Generate Sample Data</button>
                <button class="btn btn-secondary" onclick="clearData()">🗑️ Clear</button>
            </div>
            <div id="dataStatus"></div>
        </div>
        
        <div class="controls">
            <!-- Chart Configuration Section -->
            <div class="control-section">
                <h3>📊 Chart Configuration</h3>
            <div class="control-group">
                <label for="chartType">Chart Type:</label>
                <select id="chartType" onchange="updateChart()">
                    <option value="candlestick">Standard Candlestick</option>
                    <option value="scatter">Scatter Plot</option>
                    <option value="line">Line Chart</option>
                    <option value="histogram">Histogram</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="numRows">Number of Rows:</label>
                <input type="number" id="numRows" min="10" max="1000" value="200" onchange="handleNumRowsChange()">
            </div>
            
            <div class="control-group" id="candleWidthGroup">
                <label for="candleWidth">Candle Width:</label>
                <input type="range" id="candleWidth" min="2" max="20" value="8" onchange="updateChart()">
            </div>
            
                <div class="control-group">
                    <label for="showVolume">Show Volume:</label>
                    <select id="showVolume" onchange="updateChart()">
                        <option value="true">Yes</option>
                        <option value="false">No</option>
                    </select>
                </div>
            </div>
            
            <!-- Axis Configuration Section -->
            <div class="control-section">
                <h3>📈 Axis Configuration</h3>
            <div class="control-group" id="xAxisGroup" style="display: none;">
                <label for="xAxis">X-Axis Feature:</label>
                <select id="xAxis" onchange="updateChart()">
                    <option value="timestamp">Timestamp</option>
                    <option value="open">Open Price</option>
                    <option value="high">High Price</option>
                    <option value="low">Low Price</option>
                    <option value="close">Close Price</option>
                    <option value="volume">Volume</option>
                </select>
            </div>
            
            <div class="control-group" id="yAxisGroup" style="display: none;">
                <label for="yAxis">Y-Axis Feature:</label>
                <select id="yAxis" onchange="updateChart()">
                    <option value="close">Close Price</option>
                    <option value="open">Open Price</option>
                    <option value="high">High Price</option>
                    <option value="low">Low Price</option>
                    <option value="volume">Volume</option>
                </select>
            </div>
            
            <div class="control-group" id="histogramGroup" style="display: none;">
                <label for="histogramFeature">Histogram Feature:</label>
                <select id="histogramFeature" onchange="updateChart()">
                    <option value="close">Close Price</option>
                    <option value="open">Open Price</option>
                    <option value="high">High Price</option>
                    <option value="low">Low Price</option>
                    <option value="volume">Volume</option>
                </select>
            </div>
            </div>
            
            <!-- Filtering Section -->
            <div class="control-section">
                <h3>🔍 Data Filtering</h3>
            <div class="control-group">
                <label for="clusterFilter">Filter by Cluster:</label>
                <select id="clusterFilter" onchange="updateChart()">
                    <option value="all">All Clusters</option>
                    <option value="0">Cluster 0</option>
                    <option value="1">Cluster 1</option>
                    <option value="2">Cluster 2</option>
                    <option value="3">Cluster 3</option>
                </select>
            </div>
                
                <div class="control-group">
                    <label for="candleTypeFilter">Filter by Candle Type:</label>
                    <select id="candleTypeFilter" onchange="updateChart()">
                        <option value="all">All Candles</option>
                        <option value="bullish">Bullish (Green)</option>
                        <option value="bearish">Bearish (Red)</option>
                    </select>
        </div>
        
                <div class="control-group">
                    <label for="candlePatternFilter">Filter by Candle Pattern:</label>
                    <select id="candlePatternFilter" onchange="updateChart()">
                        <option value="all">All Patterns</option>
                        <option value="doji">Doji</option>
                        <option value="marubozu">Marubozu</option>
                        <option value="hammer">Hammer</option>
                        <option value="hanging_man">Hanging Man</option>
                        <option value="shooting_star">Shooting Star</option>
                        <option value="inverted_hammer">Inverted Hammer</option>
                        <option value="spinning_top">Spinning Top</option>
                        <option value="long_legged_doji">Long Legged Doji</option>
                    </select>
                </div>
            </div>
            
            <!-- Visual Styling Section -->
            <div class="control-section">
                <h3>🎨 Visual Styling</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="showClusterColors" checked onchange="updateChart()">
                    <label for="showClusterColors">Show Cluster Colors</label>
                </div>
                
                <div class="control-group">
                    <label for="patternColorMode">Pattern Color Mode:</label>
                    <select id="patternColorMode" onchange="updateChart()">
                        <option value="bullish_bearish">Bullish/Bearish Colors</option>
                        <option value="pattern_specific">Pattern Specific Colors</option>
                        <option value="no_colors">No Pattern Colors</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div class="legend">
            <h3>📊 Chart Legend</h3>
            <div class="legend-content" id="legend"></div>
        </div>
        
        <div class="stats">
            <h3>📈 Statistics</h3>
            <div class="stats-content" id="stats"></div>
        </div>
        
        <!-- Settings Container (Outside Chart) -->
        <div class="settings-container">
            <!-- Settings Button -->
            <div class="overlay-settings" onclick="toggleSettings()">⚙️ Settings</div>
            <!-- Reset Button -->
            <div class="overlay-settings" onclick="resetChartToDefault()" style="margin-left: 10px;">🔄 Reset</div>
            
            <!-- Settings Panel -->
            <div class="overlay-settings-panel hidden" id="overlaySettingsPanel">
                <div class="overlay-settings-group">
                    <label>Panel Opacity</label>
                    <input type="range" id="panelOpacity" min="0.3" max="1" step="0.1" value="0.8" onchange="updatePanelOpacity()">
                    <div class="overlay-settings-value" id="opacityValue">80%</div>
                </div>
                
                <div class="overlay-settings-group">
                    <label style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">Panel Visibility</label>
                    <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                        <button class="overlay-panel-btn" onclick="selectAllPanels()" style="font-size: 9px; padding: 2px 6px;">All</button>
                        <button class="overlay-panel-btn" onclick="deselectAllPanels()" style="font-size: 9px; padding: 2px 6px;">None</button>
                    </div>
                    <div class="panel-visibility-grid">
                        <label class="panel-checkbox">
                            <input type="checkbox" id="showChartPanel" checked onchange="updatePanelVisibility()">
                            📊 Chart
                        </label>
                        <label class="panel-checkbox">
                            <input type="checkbox" id="showFiltersPanel" checked onchange="updatePanelVisibility()">
                            🔍 Filters
                        </label>
                        <label class="panel-checkbox">
                            <input type="checkbox" id="showColorsPanel" checked onchange="updatePanelVisibility()">
                            🎨 Colors
                        </label>
                        <label class="panel-checkbox">
                            <input type="checkbox" id="showStatsPanel" checked onchange="updatePanelVisibility()">
                            📈 Stats
                        </label>
                        <label class="panel-checkbox">
                            <input type="checkbox" id="showLegendPanel" checked onchange="updatePanelVisibility()">
                            📊 Legend
                        </label>
                    </div>
                </div>
                
                <div class="overlay-settings-group">
                    <label>
                        <input type="checkbox" id="autoMinimize" onchange="updateAutoMinimize()">
                        Auto Minimize Panels
                    </label>
                </div>
                <div class="overlay-settings-group">
                    <label>
                        <input type="checkbox" id="showMinimizeButtons" checked onchange="updateMinimizeButtons()">
                        Show Minimize Buttons
                    </label>
                </div>
                
                <div class="overlay-settings-group">
                    <button class="overlay-panel-btn" onclick="resetZoom()" style="width: 100%; padding: 8px; font-size: 12px;">
                        🔄 Reset Zoom
                    </button>
                </div>
                
                <div class="overlay-settings-group">
                    <button class="overlay-panel-btn" onclick="resetVisibleRange()" style="width: 100%; padding: 8px; font-size: 12px;">
                        📊 Go to Latest Data
                    </button>
                </div>
                
                <div class="overlay-settings-group">
                    <button class="overlay-panel-btn" onclick="panToMiddle()" style="width: 100%; padding: 8px; font-size: 12px;">
                        🎯 Go to Middle
                    </button>
                </div>
                
                <div class="overlay-settings-group">
                    <label>Max Visible Points</label>
                    <input type="range" id="maxVisiblePoints" min="10" max="200" step="10" value="50" onchange="updateMaxVisiblePoints()">
                    <div class="overlay-settings-value" id="maxVisiblePointsValue">50</div>
                </div>
                
                <div class="overlay-settings-group">
                    <label>Panning Sensitivity</label>
                    <input type="range" id="panningSensitivity" min="0.1" max="5" step="0.1" value="1" onchange="updatePanningSensitivity()">
                    <div class="overlay-settings-value" id="panningSensitivityValue">1.0</div>
                </div>
                
                <div class="overlay-settings-group">
                    <label style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">Keyboard Shortcuts</label>
                    <div style="font-size: 10px; color: #ccc; line-height: 1.4;">
                        <div>1-4: Set visible points (20, 50, 100, 200)</div>
                        <div>← →: Pan to older/newer data</div>
                        <div>Home: Go to latest data</div>
                        <div>End: Go to earliest data</div>
                        <div>Ctrl/Shift+Mouse wheel: Adjust visible points</div>
                        <div>Page Up/Down: Adjust visible points</div>
                        <div>Drag left/right: Pan through time</div>
                        <div>+/-: Increase/decrease panning sensitivity</div>
                        <div>R: Reset chart to default</div>
                        <div>C: Toggle crosshair on/off</div>
                    </div>
                </div>
                
                <div class="overlay-settings-group">
                    <button class="overlay-panel-btn" onclick="debugChart()" style="width: 100%; padding: 8px; font-size: 12px;">
                        🐛 Debug Chart
                    </button>
                </div>
                
                <div class="overlay-settings-group">
                    <label style="font-weight: 600; color: #00ff88; margin-bottom: 8px;">Settings Management</label>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        <button class="overlay-panel-btn" onclick="saveSettingsWithNotification()" style="flex: 1; padding: 6px; font-size: 11px;">
                            💾 Save
                        </button>
                        <button class="overlay-panel-btn" onclick="loadSettings()" style="flex: 1; padding: 6px; font-size: 11px;">
                            📂 Load
                        </button>
                        <button class="overlay-panel-btn" onclick="clearSettings()" style="flex: 1; padding: 6px; font-size: 11px;">
                            🗑️ Clear
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="chart-container">
            <canvas id="candlestickChart"></canvas>
            
            <!-- Chart Overlay -->
            <div class="chart-overlay">
                
                
                <!-- All Panels on Left Side -->
                <div class="overlay-left" id="overlayLeft">
                    <!-- Chart Configuration Panel -->
                    <div class="overlay-panel" id="chartPanel">
                        <div class="overlay-panel-header" onclick="togglePanel('chartPanel')">
                            <h4>📊 Chart</h4>
                            <div class="overlay-panel-controls">
                                <button class="overlay-panel-btn minimize-btn" onclick="event.stopPropagation(); togglePanel('chartPanel')">−</button>
                            </div>
                        </div>
                        <div class="overlay-controls">
                            <div class="overlay-control-group">
                                <label>Type</label>
                                <select id="overlayChartType" onchange="updateChart()">
                                    <option value="candlestick">Candlestick</option>
                                    <option value="scatter">Scatter</option>
                                    <option value="line">Line</option>
                                    <option value="histogram">Histogram</option>
                                </select>
                            </div>
                            <div class="overlay-control-group">
                                <label>Rows</label>
                                <input type="number" id="overlayNumRows" min="10" max="1000" value="200" onchange="updateChart()">
                            </div>
                            <div class="overlay-control-group" id="overlayCandleWidthGroup">
                                <label>Width</label>
                                <input type="range" id="overlayCandleWidth" min="2" max="20" value="8" onchange="updateChart()">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Filters Panel -->
                    <div class="overlay-panel" id="filtersPanel">
                        <div class="overlay-panel-header" onclick="togglePanel('filtersPanel')">
                            <h4>🔍 Filters</h4>
                            <div class="overlay-panel-controls">
                                <button class="overlay-panel-btn minimize-btn" onclick="event.stopPropagation(); togglePanel('filtersPanel')">−</button>
                            </div>
                        </div>
                        <div class="overlay-controls">
                            <div class="overlay-control-group">
                                <label>Cluster</label>
                                <select id="overlayClusterFilter" onchange="updateChart()">
                                    <option value="all">All</option>
                                    <option value="0">Cluster 0</option>
                                    <option value="1">Cluster 1</option>
                                    <option value="2">Cluster 2</option>
                                    <option value="3">Cluster 3</option>
                                </select>
                            </div>
                            <div class="overlay-control-group">
                                <label>Candle Type</label>
                                <select id="overlayCandleTypeFilter" onchange="updateChart()">
                                    <option value="all">All</option>
                                    <option value="bullish">Bullish</option>
                                    <option value="bearish">Bearish</option>
                                </select>
                            </div>
                            <div class="overlay-control-group">
                                <label>Pattern</label>
                                <select id="overlayCandlePatternFilter" onchange="updateChart()">
                                    <option value="all">All</option>
                                    <option value="doji">Doji</option>
                                    <option value="marubozu">Marubozu</option>
                                    <option value="hammer">Hammer</option>
                                    <option value="hanging_man">Hanging Man</option>
                                    <option value="shooting_star">Shooting Star</option>
                                    <option value="inverted_hammer">Inverted Hammer</option>
                                    <option value="spinning_top">Spinning Top</option>
                                    <option value="long_legged_doji">Long Legged Doji</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Colors Panel -->
                    <div class="overlay-panel" id="colorsPanel">
                        <div class="overlay-panel-header" onclick="togglePanel('colorsPanel')">
                            <h4>🎨 Colors</h4>
                            <div class="overlay-panel-controls">
                                <button class="overlay-panel-btn minimize-btn" onclick="event.stopPropagation(); togglePanel('colorsPanel')">−</button>
                            </div>
                        </div>
                        <div class="overlay-controls">
                            <div class="overlay-control-group">
                                <label>
                                    <input type="checkbox" id="overlayShowClusterColors" checked onchange="updateChart()" style="margin-right: 6px;">
                                    Cluster Colors
                                </label>
                            </div>
                            <div class="overlay-control-group">
                                <label>Pattern Mode</label>
                                <select id="overlayPatternColorMode" onchange="updateChart()">
                                    <option value="bullish_bearish">Bullish/Bearish</option>
                                    <option value="pattern_specific">Pattern Specific</option>
                                    <option value="no_colors">No Colors</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Statistics Panel -->
                    <div class="overlay-panel" id="statsPanel">
                        <div class="overlay-panel-header" onclick="togglePanel('statsPanel')">
                            <h4>📈 Stats</h4>
                            <div class="overlay-panel-controls">
                                <button class="overlay-panel-btn minimize-btn" onclick="event.stopPropagation(); togglePanel('statsPanel')">−</button>
                            </div>
                        </div>
                        <div class="overlay-stats" id="overlayStats">
                            <!-- Stats will be populated by JavaScript -->
                        </div>
                    </div>
                    
                    <!-- Legend Panel -->
                    <div class="overlay-panel" id="legendPanel">
                        <div class="overlay-panel-header" onclick="togglePanel('legendPanel')">
                            <h4>📊 Legend</h4>
                            <div class="overlay-panel-controls">
                                <button class="overlay-panel-btn minimize-btn" onclick="event.stopPropagation(); togglePanel('legendPanel')">−</button>
                            </div>
                        </div>
                        <div class="overlay-legend" id="overlayLegend">
                            <!-- Legend will be populated by JavaScript -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // CSV data will be loaded and processed
        let stockData = [];
        let filteredData = [];
        let canvas, ctx;
        let chartArea = { x: 80, y: 60, width: 0, height: 0 };
        
        // Interactive chart variables
        let isMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let panOffsetX = 0;
        let panOffsetY = 0;
        let zoomLevel = 1;
        let zoomCenterX = 0;
        let zoomCenterY = 0;
        let hoveredIndex = -1;
        let crosshairX = -1;
        let crosshairY = -1;
        let lastCrosshairX = -1;
        let lastCrosshairY = -1;
        let crosshairEnabled = true;
        let crosshairAnimationFrame = null;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        
        // Range-based panning variables
        let visibleStartIndex = 0;
        let visibleEndIndex = 0;
        let maxVisiblePoints = 50;
        let panningSensitivity = 1.0; // Number of data points to show at once
        
        // Cluster colors - vibrant and distinct
        const clusterColors = {
            0: { main: '#00ff88', shadow: 'rgba(0, 255, 136, 0.3)' },
            1: { main: '#ff6b6b', shadow: 'rgba(255, 107, 107, 0.3)' },
            2: { main: '#4ecdc4', shadow: 'rgba(78, 205, 196, 0.3)' },
            3: { main: '#ffe66d', shadow: 'rgba(255, 230, 109, 0.3)' }
        };
        
        // Default colors when cluster coloring is disabled
        const defaultColors = {
            bullish: { main: '#00ff88', shadow: 'rgba(0, 255, 136, 0.3)' },
            bearish: { main: '#ff6b6b', shadow: 'rgba(255, 107, 107, 0.3)' },
            neutral: { main: '#4ecdc4', shadow: 'rgba(78, 205, 196, 0.3)' }
        };
        
        // Candle pattern detection functions
        function detectCandlePattern(data) {
            const { open, high, low, close } = data;
            const bodySize = Math.abs(close - open);
            const upperShadow = high - Math.max(open, close);
            const lowerShadow = Math.min(open, close) - low;
            const totalRange = high - low;
            
            // Avoid division by zero
            if (totalRange === 0) return 'doji';
            
            const bodyRatio = bodySize / totalRange;
            const upperShadowRatio = upperShadow / totalRange;
            const lowerShadowRatio = lowerShadow / totalRange;
            
            // Doji patterns
            if (bodyRatio < 0.1) {
                if (upperShadowRatio > 0.3 && lowerShadowRatio > 0.3) {
                    return 'long_legged_doji';
                }
                return 'doji';
            }
            
            // Marubozu (small shadows)
            if (upperShadowRatio < 0.1 && lowerShadowRatio < 0.1) {
                return 'marubozu';
            }
            
            // Hammer patterns (long lower shadow, small upper shadow)
            if (lowerShadowRatio > 0.6 && upperShadowRatio < 0.2 && bodyRatio > 0.1) {
                if (close > open) {
                    return 'hammer';
                } else {
                    return 'hanging_man';
                }
            }
            
            // Shooting star patterns (long upper shadow, small lower shadow)
            if (upperShadowRatio > 0.6 && lowerShadowRatio < 0.2 && bodyRatio > 0.1) {
                if (close < open) {
                    return 'shooting_star';
                } else {
                    return 'inverted_hammer';
                }
            }
            
            // Spinning top (small body, both shadows present)
            if (bodyRatio < 0.3 && upperShadowRatio > 0.2 && lowerShadowRatio > 0.2) {
                return 'spinning_top';
            }
            
            // Default to basic bullish/bearish
            return close > open ? 'bullish' : 'bearish';
        }
        
        // Get candle pattern color
        function getCandlePatternColor(pattern) {
            const patternColors = {
                doji: { main: '#ffe66d', shadow: 'rgba(255, 230, 109, 0.3)' },
                long_legged_doji: { main: '#ff9ff3', shadow: 'rgba(255, 159, 243, 0.3)' },
                marubozu: { main: '#ff6b6b', shadow: 'rgba(255, 107, 107, 0.3)' },
                hammer: { main: '#00ff88', shadow: 'rgba(0, 255, 136, 0.3)' },
                hanging_man: { main: '#ff6b6b', shadow: 'rgba(255, 107, 107, 0.3)' },
                shooting_star: { main: '#ff6b6b', shadow: 'rgba(255, 107, 107, 0.3)' },
                inverted_hammer: { main: '#00ff88', shadow: 'rgba(0, 255, 136, 0.3)' },
                spinning_top: { main: '#4ecdc4', shadow: 'rgba(78, 205, 196, 0.3)' },
                bullish: { main: '#00ff88', shadow: 'rgba(0, 255, 136, 0.3)' },
                bearish: { main: '#ff6b6b', shadow: 'rgba(255, 107, 107, 0.3)' }
            };
            return patternColors[pattern] || patternColors.bullish;
        }
        
        // Helper function to get color based on cluster coloring setting
        function getDataColor(data) {
            const showClusterColors = document.getElementById('showClusterColors').checked;
            
            if (showClusterColors) {
                // Use cluster-based colors
                const cluster = data.predicted_cluster || 0;
                return clusterColors[cluster] || clusterColors[0];
            } else {
                const patternColorMode = document.getElementById('patternColorMode').value;
                
                if (patternColorMode === 'pattern_specific') {
                    // Use pattern-specific colors
                    const pattern = detectCandlePattern(data);
                    return getCandlePatternColor(pattern);
                } else if (patternColorMode === 'no_colors') {
                    // Use neutral color for all patterns
                    return defaultColors.neutral;
                } else {
                    // Use simple bullish/bearish colors (default)
                    if (data.close > data.open) {
                        return defaultColors.bullish;
                    } else if (data.close < data.open) {
                        return defaultColors.bearish;
                    } else {
                        return defaultColors.neutral;
                    }
                }
            }
        }
        
        // Initialize the application
        function init() {
            setupCanvas();
            setupInteractiveChart(); // Set up interactive features
            generateSampleData(); // Start with sample data
            syncOverlayControls(); // Sync overlay controls with main controls
            updateControlVisibility();
            updateStats();
            updateLegend();
            updateChart();
            
            // Initialize visible range after data is loaded
            initializeVisibleRange();
            
            // Initialize settings
            updatePanelOpacity();
            updateMinimizeButtons();
            updatePanelVisibility();
            updateMaxVisiblePoints();
            updatePanningSensitivity();
            
            // Load saved settings
            const settingsLoaded = loadSettings();
            if (settingsLoaded) {
                showStatus('📂 Settings loaded from localStorage', 'success');
                // Update chart with loaded settings
                updateChart();
                updateStats();
                updateLegend();
            }
        }

        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('dataStatus');
            statusDiv.className = type;
            statusDiv.innerHTML = message;
            setTimeout(() => {
                statusDiv.innerHTML = '';
                statusDiv.className = '';
            }, 5000);
        }

        function loadCSVData() {
            const csvContent = document.getElementById('csvInput').value.trim();
            if (!csvContent) {
                showStatus('⚠️ Please paste CSV data first', 'error');
                return;
            }

            try {
                stockData = [];
                const lines = csvContent.split('\n');
                if (lines.length < 2) {
                    throw new Error('CSV must have at least a header and one data row');
                }

                const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
                
                // Validate required headers
                const requiredHeaders = ['timestamp', 'open', 'high', 'low', 'close', 'volume'];
                const missingHeaders = requiredHeaders.filter(h => !headers.includes(h));
                if (missingHeaders.length > 0) {
                    throw new Error(`Missing required headers: ${missingHeaders.join(', ')}`);
                }

                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const values = line.split(',').map(v => v.trim().replace(/"/g, ''));
                    if (values.length !== headers.length) {
                        console.warn(`Row ${i + 1} has ${values.length} values but expected ${headers.length}`);
                        continue;
                    }

                    const row = {};
                    headers.forEach((header, index) => {
                        let value = values[index];
                        
                        // Parse numeric values
                        if (['open', 'high', 'low', 'close', 'volume', 'predicted_cluster'].includes(header)) {
                            value = parseFloat(value) || 0;
                        }
                        
                        row[header] = value;
                    });
                    
                    // Convert timestamp to Date object
                    if (row.timestamp) {
                        row.date = new Date(row.timestamp);
                        if (isNaN(row.date.getTime())) {
                            console.warn(`Invalid date in row ${i + 1}: ${row.timestamp}`);
                            continue;
                        }
                    }
                    
                    // Set default cluster if not provided
                    if (row.predicted_cluster === undefined) {
                        row.predicted_cluster = 0;
                    }
                    
                    stockData.push(row);
                }
                
                if (stockData.length === 0) {
                    throw new Error('No valid data rows found');
                }

                // Update feature selectors based on CSV headers
                updateFeatureSelectors(headers);
                
                filteredData = [...stockData];
                
                // Reinitialize visible range for new data
                initializeVisibleRange();
                
                updateChart();
                updateStats();
                updateLegend();
                showStatus(`✅ Successfully loaded ${stockData.length} data points`, 'success');
                
            } catch (error) {
                console.error('Error parsing CSV:', error);
                showStatus(`❌ Error parsing CSV: ${error.message}`, 'error');
            }
        }
        
        function updateFeatureSelectors(headers) {
            // Get all numeric features from the data
            const numericFeatures = [];
            const excludeHeaders = ['timestamp', 'predicted_cluster', 'date'];
            
            // Check which headers contain numeric data by sampling the first few rows
            if (stockData.length > 0) {
                headers.forEach(header => {
                    if (!excludeHeaders.includes(header.toLowerCase())) {
                        // Check if the first few values are numeric
                        const sampleValues = stockData.slice(0, Math.min(5, stockData.length))
                            .map(row => row[header]);
                        const isNumeric = sampleValues.every(val => 
                            val !== null && val !== undefined && !isNaN(parseFloat(val))
                        );
                        if (isNumeric) {
                            numericFeatures.push(header);
                        }
                    }
                });
            } else {
                // Fallback to standard features if no data
                numericFeatures.push('open', 'high', 'low', 'close', 'volume');
            }
            
            // Add timestamp as an option for X-axis
            const xAxisOptions = ['timestamp', ...numericFeatures];
            const yAxisOptions = [...numericFeatures];
            const histogramOptions = [...numericFeatures];
            
            // Update X-axis selector
            const xAxisSelect = document.getElementById('xAxis');
            xAxisSelect.innerHTML = '';
            xAxisOptions.forEach(feature => {
                const option = document.createElement('option');
                option.value = feature;
                option.textContent = feature.charAt(0).toUpperCase() + feature.slice(1);
                xAxisSelect.appendChild(option);
            });
            
            // Update Y-axis selector
            const yAxisSelect = document.getElementById('yAxis');
            yAxisSelect.innerHTML = '';
            yAxisOptions.forEach(feature => {
                const option = document.createElement('option');
                option.value = feature;
                option.textContent = feature.charAt(0).toUpperCase() + feature.slice(1);
                yAxisSelect.appendChild(option);
            });
            
            // Update histogram selector
            const histogramSelect = document.getElementById('histogramFeature');
            histogramSelect.innerHTML = '';
            histogramOptions.forEach(feature => {
                const option = document.createElement('option');
                option.value = feature;
                option.textContent = feature.charAt(0).toUpperCase() + feature.slice(1);
                histogramSelect.appendChild(option);
            });
        }

        function clearData() {
            document.getElementById('csvInput').value = '';
            stockData = [];
            filteredData = [];
            updateChart();
            updateStats();
            updateLegend();
            showStatus('🗑️ Data cleared', 'success');
        }
        
        function handleNumRowsChange() {
            // Regenerate sample data with new number of rows
            generateSampleData();
        }
        
        function generateSampleData() {
            const numRows = parseInt(document.getElementById('numRows').value);
            stockData = [];
            const startDate = new Date('2024-09-06');
            let lastPrice = 520;
            
            for (let i = 0; i < numRows; i++) {
                const date = new Date(startDate.getTime() + i * 3600000); // Add hours
                
                // Create more realistic price movement
                const volatility = 0.02;
                const trend = Math.sin(i / 50) * 0.001;
                const randomChange = (Math.random() - 0.5) * volatility;
                const priceChange = (trend + randomChange) * lastPrice;
                
                const open = lastPrice;
                const close = open + priceChange;
                const high = Math.max(open, close) * (1 + Math.random() * 0.01);
                const low = Math.min(open, close) * (1 - Math.random() * 0.01);
                
                lastPrice = close;
                
                stockData.push({
                    date: date,
                    timestamp: date.toISOString(),
                    open: Math.round(open * 100) / 100,
                    high: Math.round(high * 100) / 100,
                    low: Math.round(low * 100) / 100,
                    close: Math.round(close * 100) / 100,
                    volume: Math.floor(Math.random() * 2000000) + 500000,
                    predicted_cluster: Math.floor(Math.random() * 4)
                });
            }
            
            // Update feature selectors for sample data
            const sampleHeaders = ['timestamp', 'open', 'high', 'low', 'close', 'volume', 'predicted_cluster'];
            updateFeatureSelectors(sampleHeaders);
            
            filteredData = [...stockData];
            
            // Reinitialize visible range for new data
            initializeVisibleRange();
            
            updateChart();
            updateStats();
            updateLegend();
            showStatus(`🎲 Generated ${stockData.length} sample data points`, 'success');
        }
        
        function setupCanvas() {
            canvas = document.getElementById('candlestickChart');
            if (!canvas) {
                console.error('Canvas element not found!');
                return;
            }
            
            ctx = canvas.getContext('2d');
            
            // Set reasonable resolution for better performance
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width * 2; // 2x for high-DPI
            canvas.height = rect.height * 2; // 2x for high-DPI
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            
            // Calculate chart area
            chartArea.width = canvas.width - 160;
            chartArea.height = canvas.height - 120;
            
            // Set up high-DPI rendering
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
        }
        
        function updateChart() {
            // Sync controls between main and overlay
            syncMainControls();
            syncOverlayControls();
            
            filterData();
            updateControlVisibility();
            drawChart();
            updateStats();
            updateOverlayStats();
            updateOverlayLegend();
            
            // Auto-save settings after chart updates
            saveSettings();
        }
        
        function redrawChart() {
            // Just redraw the chart without recalculating data
            drawChart();
        }
        
        function updateControlVisibility() {
            const chartType = document.getElementById('chartType').value;
            const candleWidthGroup = document.getElementById('candleWidthGroup');
            const xAxisGroup = document.getElementById('xAxisGroup');
            const yAxisGroup = document.getElementById('yAxisGroup');
            const histogramGroup = document.getElementById('histogramGroup');
            
            // Show/hide controls based on chart type
            if (chartType === 'candlestick') {
                candleWidthGroup.style.display = 'block';
                xAxisGroup.style.display = 'none';
                yAxisGroup.style.display = 'none';
                histogramGroup.style.display = 'none';
            } else if (chartType === 'histogram') {
                candleWidthGroup.style.display = 'none';
                xAxisGroup.style.display = 'none';
                yAxisGroup.style.display = 'none';
                histogramGroup.style.display = 'block';
            } else { // scatter or line
                candleWidthGroup.style.display = 'none';
                xAxisGroup.style.display = 'block';
                yAxisGroup.style.display = 'block';
                histogramGroup.style.display = 'none';
            }
        }
        
        function filterData() {
            const numRows = parseInt(document.getElementById('numRows').value);
            const clusterFilter = document.getElementById('clusterFilter').value;
            const candleTypeFilter = document.getElementById('candleTypeFilter').value;
            const candlePatternFilter = document.getElementById('candlePatternFilter').value;
            
            let filtered = [...stockData];
            
            // Filter by number of rows (take the last N rows)
            if (numRows && numRows < filtered.length) {
                filtered = filtered.slice(-numRows);
            }
            
            // Add visibility flags instead of removing data
            filtered = filtered.map(d => {
                let visible = true;
            
            // Filter by cluster
            if (clusterFilter !== 'all') {
                const cluster = parseInt(clusterFilter);
                    visible = visible && d.predicted_cluster === cluster;
                }
                
                // Filter by candle type (bullish/bearish)
                if (candleTypeFilter !== 'all') {
                    if (candleTypeFilter === 'bullish') {
                        visible = visible && d.close > d.open;
                    } else if (candleTypeFilter === 'bearish') {
                        visible = visible && d.close < d.open;
                    }
                }
                
                // Filter by candle pattern
                if (candlePatternFilter !== 'all') {
                    const pattern = detectCandlePattern(d);
                    visible = visible && pattern === candlePatternFilter;
                }
                
                return { ...d, visible };
            });
            
            filteredData = filtered;
        }
        
        function drawChart() {
            if (!ctx || filteredData.length === 0) {
                // Clear canvas and show message
                if (ctx) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.font = '120px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('No data to display', canvas.width / 2, canvas.height / 2);
                    ctx.font = '80px Arial';
                    ctx.fillText('Load CSV data or generate sample data', canvas.width / 2, canvas.height / 2 + 150);
                }
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, 'rgba(0, 20, 40, 0.8)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.9)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Apply pan transformations only (zoom disabled)
            ctx.save();
            ctx.translate(panOffsetX, panOffsetY);
            // ctx.scale(zoomLevel, zoomLevel); // Disabled zoom scaling
            
            const chartType = document.getElementById('chartType').value;
            
            if (chartType === 'candlestick') {
                drawCandlestickChart();
            } else if (chartType === 'scatter') {
                drawScatterChart();
            } else if (chartType === 'line') {
                drawLineChart();
            } else if (chartType === 'histogram') {
                drawHistogramChart();
            }
            
            ctx.restore();
            
            // Draw interactive elements (not affected by zoom/pan)
            drawCrosshair();
            drawTooltip();
        }
        
        function drawCandlestickChart() {
            const candleWidth = parseInt(document.getElementById('candleWidth').value);
            const showVolume = document.getElementById('showVolume').value === 'true';
            
            // Get visible data range
            const visibleData = filteredData.filter(d => d.visible);
            if (visibleData.length === 0) return;
            
            // Update visible range if needed
            updateVisibleRange();
            
            // Get the data points to display
            const displayData = visibleData.slice(visibleStartIndex, visibleEndIndex + 1);
            if (displayData.length === 0) return;
            
            // Calculate scales based on visible data
            const priceData = displayData.map(d => [d.high, d.low]).flat();
            const maxPrice = Math.max(...priceData);
            const minPrice = Math.min(...priceData);
            const priceRange = maxPrice - minPrice;
            const padding = priceRange * 0.1;
            
            const volumeData = displayData.map(d => d.volume);
            const maxVolume = Math.max(...volumeData);
            
            const chartHeight = showVolume ? chartArea.height * 0.7 : chartArea.height;
            const volumeHeight = showVolume ? chartArea.height * 0.25 : 0;
            
            const xStep = chartArea.width / displayData.length;
            
            // Draw grid
            drawGrid(minPrice - padding, maxPrice + padding, chartHeight);
            
            // Draw candlesticks
            displayData.forEach((data, i) => {
                const x = chartArea.x + i * xStep + xStep / 2;
                const color = getDataColor(data);
                
                drawCandlestick(
                    x, 
                    data.open, 
                    data.high, 
                    data.low, 
                    data.close,
                    minPrice - padding,
                    maxPrice + padding,
                    chartHeight,
                    candleWidth,
                    color
                );
                
                // Draw volume bar if enabled
                if (showVolume) {
                    drawVolumeBar(
                        x,
                        data.volume,
                        maxVolume,
                        chartArea.y + chartHeight + 40,
                        volumeHeight,
                        candleWidth,
                        color
                    );
                }
            });
            
            // Draw axes labels
            drawAxes(minPrice - padding, maxPrice + padding);
        }
        
        function drawScatterChart() {
            const xAxis = document.getElementById('xAxis').value;
            const yAxis = document.getElementById('yAxis').value;
            
            // Get data for x and y axes, handling timestamps specially
            let xData, yData;
            
            if (xAxis === 'timestamp') {
                // Convert timestamps to numeric values (milliseconds)
                xData = filteredData.map(d => {
                    if (d.date) {
                        return d.date.getTime();
                    } else if (d.timestamp) {
                        return new Date(d.timestamp).getTime();
                    }
                    return 0;
                });
            } else {
                xData = filteredData.map(d => d[xAxis]);
            }
            
            if (yAxis === 'timestamp') {
                // Convert timestamps to numeric values (milliseconds)
                yData = filteredData.map(d => {
                    if (d.date) {
                        return d.date.getTime();
                    } else if (d.timestamp) {
                        return new Date(d.timestamp).getTime();
                    }
                    return 0;
                });
            } else {
                yData = filteredData.map(d => d[yAxis]);
            }
            
            const minX = Math.min(...xData);
            const maxX = Math.max(...xData);
            const minY = Math.min(...yData);
            const maxY = Math.max(...yData);
            
            const xRange = maxX - minX;
            const yRange = maxY - minY;
            const xPadding = xRange * 0.05;
            const yPadding = yRange * 0.05;
            
            // Draw grid
            drawCustomGrid(minX - xPadding, maxX + xPadding, minY - yPadding, maxY + yPadding);
            
            // Draw scatter points
            filteredData.forEach((data, i) => {
                // Only draw if visible
                if (data.visible) {
                    const color = getDataColor(data);
                    
                    // Get x and y values, handling timestamps
                    let xValue, yValue;
                    
                    if (xAxis === 'timestamp') {
                        xValue = data.date ? data.date.getTime() : new Date(data.timestamp).getTime();
                    } else {
                        xValue = data[xAxis];
                    }
                    
                    if (yAxis === 'timestamp') {
                        yValue = data.date ? data.date.getTime() : new Date(data.timestamp).getTime();
                    } else {
                        yValue = data[yAxis];
                    }
                    
                    const x = chartArea.x + ((xValue - minX + xPadding) / (xRange + 2 * xPadding)) * chartArea.width;
                    const y = chartArea.y + chartArea.height - ((yValue - minY + yPadding) / (yRange + 2 * yPadding)) * chartArea.height;
                
                // Draw point
                ctx.fillStyle = color.main;
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                // Add glow effect
                ctx.shadowColor = color.shadow;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, 2 * Math.PI);
                ctx.fill();
                ctx.shadowBlur = 0;
                }
            });
            
            // Draw axes labels
            drawCustomAxes(minX - xPadding, maxX + xPadding, minY - yPadding, maxY + yPadding, xAxis, yAxis);
        }
        
        function drawLineChart() {
            const xAxis = document.getElementById('xAxis').value;
            const yAxis = document.getElementById('yAxis').value;
            const showClusterColors = document.getElementById('showClusterColors').checked;
            
            // Get data for x and y axes, handling timestamps specially
            let xData, yData;
            
            if (xAxis === 'timestamp') {
                // Convert timestamps to numeric values (milliseconds)
                xData = filteredData.map(d => {
                    if (d.date) {
                        return d.date.getTime();
                    } else if (d.timestamp) {
                        return new Date(d.timestamp).getTime();
                    }
                    return 0;
                });
            } else {
                xData = filteredData.map(d => d[xAxis]);
            }
            
            if (yAxis === 'timestamp') {
                // Convert timestamps to numeric values (milliseconds)
                yData = filteredData.map(d => {
                    if (d.date) {
                        return d.date.getTime();
                    } else if (d.timestamp) {
                        return new Date(d.timestamp).getTime();
                    }
                    return 0;
                });
            } else {
                yData = filteredData.map(d => d[yAxis]);
            }
            
            const minX = Math.min(...xData);
            const maxX = Math.max(...xData);
            const minY = Math.min(...yData);
            const maxY = Math.max(...yData);
            
            const xRange = maxX - minX;
            const yRange = maxY - minY;
            const xPadding = xRange * 0.05;
            const yPadding = yRange * 0.05;
            
            // Draw grid
            drawCustomGrid(minX - xPadding, maxX + xPadding, minY - yPadding, maxY + yPadding);
            
            if (showClusterColors) {
            // Group data by cluster for different colored lines
            const clusterGroups = {};
            filteredData.forEach((data, i) => {
                    // Only include visible points
                    if (data.visible) {
                const cluster = data.predicted_cluster || 0;
                if (!clusterGroups[cluster]) {
                    clusterGroups[cluster] = [];
                }
                        // Get x and y values, handling timestamps
                        let xValue, yValue;
                        
                        if (xAxis === 'timestamp') {
                            xValue = data.date ? data.date.getTime() : new Date(data.timestamp).getTime();
                        } else {
                            xValue = data[xAxis];
                        }
                        
                        if (yAxis === 'timestamp') {
                            yValue = data.date ? data.date.getTime() : new Date(data.timestamp).getTime();
                        } else {
                            yValue = data[yAxis];
                        }
                        
                clusterGroups[cluster].push({
                            x: xValue,
                            y: yValue,
                    index: i
                });
                    }
            });
            
            // Draw lines for each cluster
            Object.keys(clusterGroups).forEach(cluster => {
                const group = clusterGroups[cluster];
                const color = clusterColors[cluster] || clusterColors[0];
                
                ctx.strokeStyle = color.main;
                ctx.lineWidth = 4;
                ctx.shadowColor = color.shadow;
                ctx.shadowBlur = 10;
                
                ctx.beginPath();
                group.forEach((point, i) => {
                    const x = chartArea.x + ((point.x - minX + xPadding) / (xRange + 2 * xPadding)) * chartArea.width;
                    const y = chartArea.y + chartArea.height - ((point.y - minY + yPadding) / (yRange + 2 * yPadding)) * chartArea.height;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Draw points
                group.forEach(point => {
                    const x = chartArea.x + ((point.x - minX + xPadding) / (xRange + 2 * xPadding)) * chartArea.width;
                    const y = chartArea.y + chartArea.height - ((point.y - minY + yPadding) / (yRange + 2 * yPadding)) * chartArea.height;
                    
                    ctx.fillStyle = color.main;
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, 2 * Math.PI);
                    ctx.fill();
                });
            });
            } else {
                // Draw single line with price-based coloring
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 4;
                ctx.shadowColor = 'rgba(78, 205, 196, 0.3)';
                ctx.shadowBlur = 10;
                
                ctx.beginPath();
                let firstPoint = true;
                filteredData.forEach((data, i) => {
                    // Only draw visible points
                    if (data.visible) {
                        // Get x and y values, handling timestamps
                        let xValue, yValue;
                        
                        if (xAxis === 'timestamp') {
                            xValue = data.date ? data.date.getTime() : new Date(data.timestamp).getTime();
                        } else {
                            xValue = data[xAxis];
                        }
                        
                        if (yAxis === 'timestamp') {
                            yValue = data.date ? data.date.getTime() : new Date(data.timestamp).getTime();
                        } else {
                            yValue = data[yAxis];
                        }
                        
                        const x = chartArea.x + ((xValue - minX + xPadding) / (xRange + 2 * xPadding)) * chartArea.width;
                        const y = chartArea.y + chartArea.height - ((yValue - minY + yPadding) / (yRange + 2 * yPadding)) * chartArea.height;
                        
                        if (firstPoint) {
                            ctx.moveTo(x, y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                });
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Draw points with individual colors
                filteredData.forEach((data, i) => {
                    // Only draw visible points
                    if (data.visible) {
                        // Get x and y values, handling timestamps
                        let xValue, yValue;
                        
                        if (xAxis === 'timestamp') {
                            xValue = data.date ? data.date.getTime() : new Date(data.timestamp).getTime();
                        } else {
                            xValue = data[xAxis];
                        }
                        
                        if (yAxis === 'timestamp') {
                            yValue = data.date ? data.date.getTime() : new Date(data.timestamp).getTime();
                        } else {
                            yValue = data[yAxis];
                        }
                        
                        const x = chartArea.x + ((xValue - minX + xPadding) / (xRange + 2 * xPadding)) * chartArea.width;
                        const y = chartArea.y + chartArea.height - ((yValue - minY + yPadding) / (yRange + 2 * yPadding)) * chartArea.height;
                        const color = getDataColor(data);
                        
                        ctx.fillStyle = color.main;
                        ctx.beginPath();
                        ctx.arc(x, y, 6, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                });
            }
            
            // Draw axes labels
            drawCustomAxes(minX - xPadding, maxX + xPadding, minY - yPadding, maxY + yPadding, xAxis, yAxis);
        }
        
        function drawHistogramChart() {
            const feature = document.getElementById('histogramFeature').value;
            const showClusterColors = document.getElementById('showClusterColors').checked;
            const data = filteredData.map(d => d[feature]);
            
            const minValue = Math.min(...data);
            const maxValue = Math.max(...data);
            const range = maxValue - minValue;
            const numBins = Math.min(20, Math.floor(Math.sqrt(data.length)));
            const binWidth = range / numBins;
            
            // Create bins
            const bins = Array(numBins).fill(0);
            const binData = {};
            
            data.forEach((value, i) => {
                // Only include visible data points
                if (filteredData[i].visible) {
                const binIndex = Math.min(Math.floor((value - minValue) / binWidth), numBins - 1);
                bins[binIndex]++;
                
                if (!binData[binIndex]) {
                    binData[binIndex] = [];
                }
                binData[binIndex].push({
                    value: value,
                        data: filteredData[i]
                });
                }
            });
            
            const maxCount = Math.max(...bins);
            const barWidth = chartArea.width / numBins;
            
            // Draw histogram bars
            bins.forEach((count, binIndex) => {
                if (count === 0) return;
                
                const x = chartArea.x + binIndex * barWidth;
                const height = (count / maxCount) * chartArea.height;
                const y = chartArea.y + chartArea.height - height;
                
                if (showClusterColors) {
                // Calculate cluster distribution for this bin
                const clusterCounts = {};
                binData[binIndex].forEach(item => {
                        const cluster = item.data.predicted_cluster || 0;
                        clusterCounts[cluster] = (clusterCounts[cluster] || 0) + 1;
                });
                
                // Draw stacked bars for each cluster
                let currentY = y;
                Object.keys(clusterCounts).forEach(cluster => {
                    const clusterCount = clusterCounts[cluster];
                    const clusterHeight = (clusterCount / count) * height;
                    const color = clusterColors[cluster] || clusterColors[0];
                    
                    ctx.fillStyle = color.main;
                    ctx.fillRect(x, currentY, barWidth * 0.8, clusterHeight);
                    
                    // Add border
                    ctx.strokeStyle = color.main;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, currentY, barWidth * 0.8, clusterHeight);
                    
                    currentY += clusterHeight;
                });
                } else {
                    // Draw single color bars based on price movement
                    const bullishCount = binData[binIndex].filter(item => item.data.close > item.data.open).length;
                    const bearishCount = binData[binIndex].filter(item => item.data.close < item.data.open).length;
                    const dojiCount = binData[binIndex].filter(item => item.data.close === item.data.open).length;
                    
                    let currentY = y;
                    
                    // Draw bullish portion
                    if (bullishCount > 0) {
                        const bullishHeight = (bullishCount / count) * height;
                        const color = defaultColors.bullish;
                        ctx.fillStyle = color.main;
                        ctx.fillRect(x, currentY, barWidth * 0.8, bullishHeight);
                        ctx.strokeStyle = color.main;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, currentY, barWidth * 0.8, bullishHeight);
                        currentY += bullishHeight;
                    }
                    
                    // Draw bearish portion
                    if (bearishCount > 0) {
                        const bearishHeight = (bearishCount / count) * height;
                        const color = defaultColors.bearish;
                        ctx.fillStyle = color.main;
                        ctx.fillRect(x, currentY, barWidth * 0.8, bearishHeight);
                        ctx.strokeStyle = color.main;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, currentY, barWidth * 0.8, bearishHeight);
                        currentY += bearishHeight;
                    }
                    
                    // Draw doji portion
                    if (dojiCount > 0) {
                        const dojiHeight = (dojiCount / count) * height;
                        const color = defaultColors.neutral;
                        ctx.fillStyle = color.main;
                        ctx.fillRect(x, currentY, barWidth * 0.8, dojiHeight);
                        ctx.strokeStyle = color.main;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, currentY, barWidth * 0.8, dojiHeight);
                    }
                }
            });
            
            // Draw axes labels
            drawHistogramAxes(minValue, maxValue, maxCount, feature);
        }
        
        function drawGrid(minPrice, maxPrice, chartHeight) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 2;
            
            // Horizontal grid lines
            for (let i = 0; i <= 10; i++) {
                const y = chartArea.y + (i / 10) * chartHeight;
                ctx.beginPath();
                ctx.moveTo(chartArea.x, y);
                ctx.lineTo(chartArea.x + chartArea.width, y);
                ctx.stroke();
            }
            
            // Vertical grid lines
            const timeStep = Math.max(1, Math.floor(filteredData.length / 20));
            for (let i = 0; i < filteredData.length; i += timeStep) {
                const x = chartArea.x + (i / filteredData.length) * chartArea.width;
                ctx.beginPath();
                ctx.moveTo(x, chartArea.y);
                ctx.lineTo(x, chartArea.y + chartHeight);
                ctx.stroke();
            }
        }
        
        function drawCandlestick(x, open, high, low, close, minPrice, maxPrice, chartHeight, width, color) {
            const priceRange = maxPrice - minPrice;
            const yScale = chartHeight / priceRange;
            
            const openY = chartArea.y + chartHeight - (open - minPrice) * yScale;
            const closeY = chartArea.y + chartHeight - (close - minPrice) * yScale;
            const highY = chartArea.y + chartHeight - (high - minPrice) * yScale;
            const lowY = chartArea.y + chartHeight - (low - minPrice) * yScale;
            
            const isGreen = close > open;
            const bodyHeight = Math.abs(closeY - openY);
            const bodyTop = Math.min(openY, closeY);
            
            // Draw shadow (wick)
            ctx.strokeStyle = color.main;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(x, highY);
            ctx.lineTo(x, lowY);
            ctx.stroke();
            
            // Draw body
            ctx.fillStyle = isGreen ? color.main : 'rgba(255, 0, 0, 0.8)';
            ctx.strokeStyle = color.main;
            ctx.lineWidth = 3;
            
            if (bodyHeight < 6) {
                // Draw as line for very small bodies
                ctx.beginPath();
                ctx.moveTo(x - width/2, openY);
                ctx.lineTo(x + width/2, openY);
                ctx.stroke();
            } else {
                // Draw rectangle body
                ctx.fillRect(x - width/2, bodyTop, width, bodyHeight);
                ctx.strokeRect(x - width/2, bodyTop, width, bodyHeight);
            }
            
            // Add glow effect
            ctx.shadowColor = color.shadow;
            ctx.shadowBlur = 20;
            ctx.strokeRect(x - width/2, bodyTop, width, bodyHeight);
            ctx.shadowBlur = 0;
        }
        
        function drawVolumeBar(x, volume, maxVolume, startY, maxHeight, width, color) {
            const height = (volume / maxVolume) * maxHeight;
            
            ctx.fillStyle = color.shadow;
            ctx.fillRect(x - width/2, startY + maxHeight - height, width, height);
            
            ctx.strokeStyle = color.main;
            ctx.lineWidth = 2;
            ctx.strokeRect(x - width/2, startY + maxHeight - height, width, height);
        }
        
        function drawAxes(minPrice, maxPrice) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '48px Arial';
            ctx.textAlign = 'right';
            
            // Price labels
            for (let i = 0; i <= 10; i++) {
                const price = minPrice + (maxPrice - minPrice) * (i / 10);
                const y = chartArea.y + chartArea.height - (i / 10) * chartArea.height;
                ctx.fillText(price.toFixed(2), chartArea.x - 20, y + 15);
            }
            
            // Time labels
            ctx.textAlign = 'center';
            const timeStep = Math.max(1, Math.floor(filteredData.length / 10));
            for (let i = 0; i < filteredData.length; i += timeStep) {
                if (filteredData[i] && filteredData[i].date) {
                    const x = chartArea.x + (i / filteredData.length) * chartArea.width;
                    const timeStr = filteredData[i].date.toLocaleDateString('en-US', { 
                        month: 'short', 
                        day: 'numeric' 
                    });
                    ctx.fillText(timeStr, x, chartArea.y + chartArea.height + 50);
                }
            }
        }
        
        function drawCustomGrid(minX, maxX, minY, maxY) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 2;
            
            // Horizontal grid lines
            for (let i = 0; i <= 10; i++) {
                const y = chartArea.y + (i / 10) * chartArea.height;
                ctx.beginPath();
                ctx.moveTo(chartArea.x, y);
                ctx.lineTo(chartArea.x + chartArea.width, y);
                ctx.stroke();
            }
            
            // Vertical grid lines
            for (let i = 0; i <= 10; i++) {
                const x = chartArea.x + (i / 10) * chartArea.width;
                ctx.beginPath();
                ctx.moveTo(x, chartArea.y);
                ctx.lineTo(x, chartArea.y + chartArea.height);
                ctx.stroke();
            }
        }
        
        function drawCustomAxes(minX, maxX, minY, maxY, xLabel, yLabel) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '48px Arial';
            ctx.textAlign = 'right';
            
            // Y-axis labels
            for (let i = 0; i <= 10; i++) {
                const value = minY + (maxY - minY) * (i / 10);
                const y = chartArea.y + chartArea.height - (i / 10) * chartArea.height;
                
                // Format timestamp values differently
                if (yLabel === 'timestamp') {
                    const date = new Date(value);
                    ctx.fillText(date.toLocaleDateString('en-US', { 
                        month: 'short', 
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    }), chartArea.x - 20, y + 15);
                } else {
                ctx.fillText(value.toFixed(2), chartArea.x - 20, y + 15);
                }
            }
            
            // X-axis labels
            ctx.textAlign = 'center';
            for (let i = 0; i <= 10; i++) {
                const value = minX + (maxX - minX) * (i / 10);
                const x = chartArea.x + (i / 10) * chartArea.width;
                
                // Format timestamp values differently
                if (xLabel === 'timestamp') {
                    const date = new Date(value);
                    ctx.fillText(date.toLocaleDateString('en-US', { 
                        month: 'short', 
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    }), x, chartArea.y + chartArea.height + 50);
                } else {
                ctx.fillText(value.toFixed(2), x, chartArea.y + chartArea.height + 50);
                }
            }
            
            // Axis titles
            ctx.textAlign = 'center';
            ctx.font = '60px Arial';
            ctx.fillText(yLabel, 30, chartArea.y + chartArea.height / 2);
            ctx.fillText(xLabel, chartArea.x + chartArea.width / 2, chartArea.y + chartArea.height + 100);
        }
        
        function drawHistogramAxes(minValue, maxValue, maxCount, feature) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '48px Arial';
            ctx.textAlign = 'right';
            
            // Y-axis labels (count)
            for (let i = 0; i <= 10; i++) {
                const count = (maxCount * i) / 10;
                const y = chartArea.y + chartArea.height - (i / 10) * chartArea.height;
                ctx.fillText(Math.round(count).toString(), chartArea.x - 20, y + 15);
            }
            
            // X-axis labels (value range)
            ctx.textAlign = 'center';
            for (let i = 0; i <= 10; i++) {
                const value = minValue + (maxValue - minValue) * (i / 10);
                const x = chartArea.x + (i / 10) * chartArea.width;
                ctx.fillText(value.toFixed(2), x, chartArea.y + chartArea.height + 50);
            }
            
            // Axis titles
            ctx.textAlign = 'center';
            ctx.font = '60px Arial';
            ctx.fillText('Count', 30, chartArea.y + chartArea.height / 2);
            ctx.fillText(feature, chartArea.x + chartArea.width / 2, chartArea.y + chartArea.height + 100);
        }
        
        function updateLegend() {
            const legend = document.getElementById('legend');
            legend.innerHTML = '';
            
            if (filteredData.length === 0) return;
            
            const showClusterColors = document.getElementById('showClusterColors').checked;
            
            if (showClusterColors) {
                // Show cluster information
                const uniqueClusters = [...new Set(filteredData.filter(d => d.visible).map(d => d.predicted_cluster || 0))].sort();
            
            uniqueClusters.forEach(cluster => {
                const color = clusterColors[cluster] || clusterColors[0];
                    const count = filteredData.filter(d => d.visible && (d.predicted_cluster || 0) === cluster).length;
                
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background-color: ${color.main}"></div>
                    <span>Cluster ${cluster} (${count} points)</span>
                `;
                legend.appendChild(item);
            });
            } else {
                // Show candle pattern information based on color mode
                const visibleData = filteredData.filter(d => d.visible);
                const patternCounts = {};
                const patternColorMode = document.getElementById('patternColorMode').value;
                
                visibleData.forEach(d => {
                    const pattern = detectCandlePattern(d);
                    patternCounts[pattern] = (patternCounts[pattern] || 0) + 1;
                });
                
                // Sort patterns by count (descending)
                const sortedPatterns = Object.keys(patternCounts).sort((a, b) => patternCounts[b] - patternCounts[a]);
                
                sortedPatterns.forEach(pattern => {
                    const count = patternCounts[pattern];
                    const displayName = pattern.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    
                    let color;
                    if (patternColorMode === 'pattern_specific') {
                        // Use pattern-specific colors
                        color = getCandlePatternColor(pattern).main;
                    } else if (patternColorMode === 'no_colors') {
                        // Use neutral color for all
                        color = defaultColors.neutral.main;
                    } else {
                        // Use simple color based on bullish/bearish nature
                        if (pattern.includes('bullish') || pattern === 'hammer' || pattern === 'inverted_hammer') {
                            color = defaultColors.bullish.main;
                        } else if (pattern.includes('bearish') || pattern === 'hanging_man' || pattern === 'shooting_star' || pattern === 'marubozu') {
                            color = defaultColors.bearish.main;
                        } else {
                            color = defaultColors.neutral.main;
                        }
                    }
                    
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    item.innerHTML = `
                        <div class="legend-color" style="background-color: ${color}"></div>
                        <span>${displayName} (${count} candles)</span>
                    `;
                    legend.appendChild(item);
                });
            }
            
            // Add candle type information if filter is applied
            const candleTypeFilter = document.getElementById('candleTypeFilter').value;
            if (candleTypeFilter !== 'all') {
                const candleTypeItem = document.createElement('div');
                candleTypeItem.className = 'legend-item';
                const candleTypeColor = candleTypeFilter === 'bullish' ? '#00ff88' : '#ff6b6b';
                const candleTypeLabel = candleTypeFilter === 'bullish' ? 'Bullish' : 'Bearish';
                candleTypeItem.innerHTML = `
                    <div class="legend-color" style="background-color: ${candleTypeColor}"></div>
                    <span>${candleTypeLabel} Candles Only</span>
                `;
                legend.appendChild(candleTypeItem);
            }
            
            // Add candle pattern information if filter is applied
            const candlePatternFilter = document.getElementById('candlePatternFilter').value;
            if (candlePatternFilter !== 'all') {
                const candlePatternItem = document.createElement('div');
                candlePatternItem.className = 'legend-item';
                
                const patternColorMode = document.getElementById('patternColorMode').value;
                let color;
                
                if (patternColorMode === 'pattern_specific') {
                    // Use pattern-specific colors
                    color = getCandlePatternColor(candlePatternFilter).main;
                } else if (patternColorMode === 'no_colors') {
                    // Use neutral color for all
                    color = defaultColors.neutral.main;
                } else {
                    // Use simple color based on bullish/bearish nature
                    if (candlePatternFilter.includes('bullish') || candlePatternFilter === 'hammer' || candlePatternFilter === 'inverted_hammer') {
                        color = defaultColors.bullish.main;
                    } else if (candlePatternFilter.includes('bearish') || candlePatternFilter === 'hanging_man' || candlePatternFilter === 'shooting_star' || candlePatternFilter === 'marubozu') {
                        color = defaultColors.bearish.main;
                    } else {
                        color = defaultColors.neutral.main;
                    }
                }
                
                const patternLabel = candlePatternFilter.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                candlePatternItem.innerHTML = `
                    <div class="legend-color" style="background-color: ${color}"></div>
                    <span>${patternLabel} Pattern Only</span>
                `;
                legend.appendChild(candlePatternItem);
            }
        }
        
        function updateStats() {
            const statsContainer = document.getElementById('stats');
            if (filteredData.length === 0) {
                statsContainer.innerHTML = '<div class="stat-card"><div class="stat-value">No Data</div><div class="stat-label">Load data to see stats</div></div>';
                return;
            }
            
            // Only use visible data for calculations
            const visibleData = filteredData.filter(d => d.visible);
            const prices = visibleData.map(d => d.close);
            const volumes = visibleData.map(d => d.volume);
            
            if (visibleData.length === 0) {
                document.getElementById('stats').innerHTML = '<div class="stat-card"><div class="stat-value">No Visible Data</div><div class="stat-label">Adjust filters to see data</div></div>';
                return;
            }
            
            const minPrice = Math.min(...prices);
            const maxPrice = Math.max(...prices);
            const avgPrice = prices.reduce((a, b) => a + b, 0) / prices.length;
            const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
            
            // Calculate cluster distribution
            const clusterCounts = {};
            visibleData.forEach(d => {
                const cluster = d.predicted_cluster || 0;
                clusterCounts[cluster] = (clusterCounts[cluster] || 0) + 1;
            });
            
            // Calculate candle pattern statistics
            const patternCounts = {};
            visibleData.forEach(d => {
                const pattern = detectCandlePattern(d);
                patternCounts[pattern] = (patternCounts[pattern] || 0) + 1;
            });
            
            // Get top patterns for display
            const sortedPatterns = Object.keys(patternCounts).sort((a, b) => patternCounts[b] - patternCounts[a]);
            const topPatterns = sortedPatterns.slice(0, 3); // Top 3 patterns
            
            let statsHtml = `
                <div class="stat-card">
                    <div class="stat-value">${visibleData.length}</div>
                    <div class="stat-label">Visible Points</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${filteredData.length}</div>
                    <div class="stat-label">Total Points</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">₹${avgPrice.toFixed(2)}</div>
                    <div class="stat-label">Avg Price</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">₹${minPrice.toFixed(2)}</div>
                    <div class="stat-label">Min Price</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">₹${maxPrice.toFixed(2)}</div>
                    <div class="stat-label">Max Price</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${(avgVolume / 1000000).toFixed(2)}M</div>
                    <div class="stat-label">Avg Volume</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${Object.keys(clusterCounts).length}</div>
                    <div class="stat-label">Active Clusters</div>
                </div>
            `;
            
            // Add top candle patterns
            const patternColorMode = document.getElementById('patternColorMode').value;
            topPatterns.forEach((pattern, index) => {
                const count = patternCounts[pattern];
                const displayName = pattern.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                
                let color;
                if (patternColorMode === 'pattern_specific') {
                    // Use pattern-specific colors
                    color = getCandlePatternColor(pattern).main;
                } else if (patternColorMode === 'no_colors') {
                    // Use neutral color for all
                    color = defaultColors.neutral.main;
                } else {
                    // Use simple color based on bullish/bearish nature
                    if (pattern.includes('bullish') || pattern === 'hammer' || pattern === 'inverted_hammer') {
                        color = defaultColors.bullish.main;
                    } else if (pattern.includes('bearish') || pattern === 'hanging_man' || pattern === 'shooting_star' || pattern === 'marubozu') {
                        color = defaultColors.bearish.main;
                    } else {
                        color = defaultColors.neutral.main;
                    }
                }
                
                statsHtml += `
                    <div class="stat-card">
                        <div class="stat-value" style="color: ${color}">${count}</div>
                        <div class="stat-label">${displayName}</div>
                    </div>
                `;
            });
            
            statsContainer.innerHTML = statsHtml;
        }
        
        
        // Settings panel toggle
        function toggleSettings() {
            const settingsPanel = document.getElementById('overlaySettingsPanel');
            settingsPanel.classList.toggle('hidden');
        }
        
        // Panel minimize/maximize functionality
        function togglePanel(panelId) {
            const panel = document.getElementById(panelId);
            const minimizeBtn = panel.querySelector('.minimize-btn');
            
            if (panel.classList.contains('minimized')) {
                panel.classList.remove('minimized');
                minimizeBtn.textContent = '−';
            } else {
                panel.classList.add('minimized');
                minimizeBtn.textContent = '+';
            }
        }
        
        // Update panel opacity
        function updatePanelOpacity() {
            const opacity = document.getElementById('panelOpacity').value;
            const opacityValue = document.getElementById('opacityValue');
            const panels = document.querySelectorAll('.overlay-panel');
            
            opacityValue.textContent = Math.round(opacity * 100) + '%';
            
            panels.forEach(panel => {
                panel.style.background = `rgba(0, 0, 0, ${opacity})`;
            });
        }
        
        // Update auto minimize setting
        function updateAutoMinimize() {
            const autoMinimize = document.getElementById('autoMinimize').checked;
            const panels = document.querySelectorAll('.overlay-panel');
            
            if (autoMinimize) {
                // Auto minimize all panels after 5 seconds of inactivity
                let timeoutId;
                const resetTimeout = () => {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => {
                        panels.forEach(panel => {
                            if (!panel.classList.contains('minimized')) {
                                panel.classList.add('minimized');
                                const minimizeBtn = panel.querySelector('.minimize-btn');
                                if (minimizeBtn) minimizeBtn.textContent = '+';
                            }
                        });
                    }, 5000);
                };
                
                // Reset timeout on any interaction
                panels.forEach(panel => {
                    panel.addEventListener('mouseenter', resetTimeout);
                    panel.addEventListener('click', resetTimeout);
                });
                
                resetTimeout();
            }
        }
        
        // Update minimize buttons visibility
        function updateMinimizeButtons() {
            const showButtons = document.getElementById('showMinimizeButtons').checked;
            const minimizeButtons = document.querySelectorAll('.minimize-btn');
            
            minimizeButtons.forEach(btn => {
                btn.style.display = showButtons ? 'block' : 'none';
            });
        }
        
        // Update panel visibility based on checkboxes
        function updatePanelVisibility() {
            const panels = {
                'chartPanel': document.getElementById('showChartPanel').checked,
                'filtersPanel': document.getElementById('showFiltersPanel').checked,
                'colorsPanel': document.getElementById('showColorsPanel').checked,
                'statsPanel': document.getElementById('showStatsPanel').checked,
                'legendPanel': document.getElementById('showLegendPanel').checked
            };
            
            // Show/hide individual panels
            Object.keys(panels).forEach(panelId => {
                const panel = document.getElementById(panelId);
                if (panel) {
                    panel.style.display = panels[panelId] ? 'block' : 'none';
                }
            });
            
            // Left panel is always visible (no toggle button)
            const leftPanel = document.getElementById('overlayLeft');
            leftPanel.style.display = 'flex';
        }
        
        // Select all panels
        function selectAllPanels() {
            const checkboxes = [
                'showChartPanel',
                'showFiltersPanel', 
                'showColorsPanel',
                'showStatsPanel',
                'showLegendPanel'
            ];
            
            checkboxes.forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.checked = true;
                }
            });
            
            updatePanelVisibility();
        }
        
        // Deselect all panels
        function deselectAllPanels() {
            const checkboxes = [
                'showChartPanel',
                'showFiltersPanel', 
                'showColorsPanel',
                'showStatsPanel',
                'showLegendPanel'
            ];
            
            checkboxes.forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.checked = false;
                }
            });
            
            updatePanelVisibility();
        }
        
        // Sync overlay controls with main controls
        function syncOverlayControls() {
            // Chart type
            const mainChartType = document.getElementById('chartType');
            const overlayChartType = document.getElementById('overlayChartType');
            if (mainChartType && overlayChartType) {
                overlayChartType.value = mainChartType.value;
            }
            
            // Number of rows
            const mainNumRows = document.getElementById('numRows');
            const overlayNumRows = document.getElementById('overlayNumRows');
            if (mainNumRows && overlayNumRows) {
                overlayNumRows.value = mainNumRows.value;
            }
            
            // Candle width
            const mainCandleWidth = document.getElementById('candleWidth');
            const overlayCandleWidth = document.getElementById('overlayCandleWidth');
            if (mainCandleWidth && overlayCandleWidth) {
                overlayCandleWidth.value = mainCandleWidth.value;
            }
            
            // Cluster filter
            const mainClusterFilter = document.getElementById('clusterFilter');
            const overlayClusterFilter = document.getElementById('overlayClusterFilter');
            if (mainClusterFilter && overlayClusterFilter) {
                overlayClusterFilter.value = mainClusterFilter.value;
            }
            
            // Candle type filter
            const mainCandleTypeFilter = document.getElementById('candleTypeFilter');
            const overlayCandleTypeFilter = document.getElementById('overlayCandleTypeFilter');
            if (mainCandleTypeFilter && overlayCandleTypeFilter) {
                overlayCandleTypeFilter.value = mainCandleTypeFilter.value;
            }
            
            // Candle pattern filter
            const mainCandlePatternFilter = document.getElementById('candlePatternFilter');
            const overlayCandlePatternFilter = document.getElementById('overlayCandlePatternFilter');
            if (mainCandlePatternFilter && overlayCandlePatternFilter) {
                overlayCandlePatternFilter.value = mainCandlePatternFilter.value;
            }
            
            // Show cluster colors
            const mainShowClusterColors = document.getElementById('showClusterColors');
            const overlayShowClusterColors = document.getElementById('overlayShowClusterColors');
            if (mainShowClusterColors && overlayShowClusterColors) {
                overlayShowClusterColors.checked = mainShowClusterColors.checked;
            }
            
            // Pattern color mode
            const mainPatternColorMode = document.getElementById('patternColorMode');
            const overlayPatternColorMode = document.getElementById('overlayPatternColorMode');
            if (mainPatternColorMode && overlayPatternColorMode) {
                overlayPatternColorMode.value = mainPatternColorMode.value;
            }
        }
        
        // Sync main controls with overlay controls
        function syncMainControls() {
            // Chart type
            const mainChartType = document.getElementById('chartType');
            const overlayChartType = document.getElementById('overlayChartType');
            if (mainChartType && overlayChartType) {
                mainChartType.value = overlayChartType.value;
            }
            
            // Number of rows
            const mainNumRows = document.getElementById('numRows');
            const overlayNumRows = document.getElementById('overlayNumRows');
            if (mainNumRows && overlayNumRows) {
                mainNumRows.value = overlayNumRows.value;
            }
            
            // Candle width
            const mainCandleWidth = document.getElementById('candleWidth');
            const overlayCandleWidth = document.getElementById('overlayCandleWidth');
            if (mainCandleWidth && overlayCandleWidth) {
                mainCandleWidth.value = overlayCandleWidth.value;
            }
            
            // Cluster filter
            const mainClusterFilter = document.getElementById('clusterFilter');
            const overlayClusterFilter = document.getElementById('overlayClusterFilter');
            if (mainClusterFilter && overlayClusterFilter) {
                mainClusterFilter.value = overlayClusterFilter.value;
            }
            
            // Candle type filter
            const mainCandleTypeFilter = document.getElementById('candleTypeFilter');
            const overlayCandleTypeFilter = document.getElementById('overlayCandleTypeFilter');
            if (mainCandleTypeFilter && overlayCandleTypeFilter) {
                mainCandleTypeFilter.value = overlayCandleTypeFilter.value;
            }
            
            // Candle pattern filter
            const mainCandlePatternFilter = document.getElementById('candlePatternFilter');
            const overlayCandlePatternFilter = document.getElementById('overlayCandlePatternFilter');
            if (mainCandlePatternFilter && overlayCandlePatternFilter) {
                mainCandlePatternFilter.value = overlayCandlePatternFilter.value;
            }
            
            // Show cluster colors
            const mainShowClusterColors = document.getElementById('showClusterColors');
            const overlayShowClusterColors = document.getElementById('overlayShowClusterColors');
            if (mainShowClusterColors && overlayShowClusterColors) {
                mainShowClusterColors.checked = overlayShowClusterColors.checked;
            }
            
            // Pattern color mode
            const mainPatternColorMode = document.getElementById('patternColorMode');
            const overlayPatternColorMode = document.getElementById('overlayPatternColorMode');
            if (mainPatternColorMode && overlayPatternColorMode) {
                mainPatternColorMode.value = overlayPatternColorMode.value;
            }
        }
        
        // Update overlay stats
        function updateOverlayStats() {
            const overlayStats = document.getElementById('overlayStats');
            if (!overlayStats) return;
            
            if (filteredData.length === 0) {
                overlayStats.innerHTML = '<div class="overlay-stat-item"><div class="overlay-stat-value">-</div><div class="overlay-stat-label">No Data</div></div>';
                return;
            }
            
            const visibleData = filteredData.filter(d => d.visible);
            const prices = visibleData.map(d => d.close);
            const volumes = visibleData.map(d => d.volume);
            
            const statsHtml = `
                <div class="overlay-stat-item">
                    <div class="overlay-stat-value">${visibleData.length}</div>
                    <div class="overlay-stat-label">Visible</div>
                </div>
                <div class="overlay-stat-item">
                    <div class="overlay-stat-value">${prices.length > 0 ? prices[0].toFixed(2) : '-'}</div>
                    <div class="overlay-stat-label">Current</div>
                </div>
                <div class="overlay-stat-item">
                    <div class="overlay-stat-value">${prices.length > 0 ? Math.max(...prices).toFixed(2) : '-'}</div>
                    <div class="overlay-stat-label">High</div>
                </div>
                <div class="overlay-stat-item">
                    <div class="overlay-stat-value">${prices.length > 0 ? Math.min(...prices).toFixed(2) : '-'}</div>
                    <div class="overlay-stat-label">Low</div>
                </div>
                <div class="overlay-stat-item">
                    <div class="overlay-stat-value">${volumes.length > 0 ? (volumes.reduce((a, b) => a + b, 0) / volumes.length / 1000).toFixed(0) + 'K' : '-'}</div>
                    <div class="overlay-stat-label">Avg Vol</div>
                </div>
            `;
            
            overlayStats.innerHTML = statsHtml;
        }
        
        // Update overlay legend
        function updateOverlayLegend() {
            const overlayLegend = document.getElementById('overlayLegend');
            if (!overlayLegend) return;
            
            overlayLegend.innerHTML = '';
            
            const showClusterColors = document.getElementById('showClusterColors').checked;
            
            if (showClusterColors) {
                // Show cluster information
                const visibleData = filteredData.filter(d => d.visible);
                const clusterCounts = {};
                
                visibleData.forEach(d => {
                    const cluster = d.predicted_cluster || 0;
                    clusterCounts[cluster] = (clusterCounts[cluster] || 0) + 1;
                });
                
                Object.keys(clusterCounts).forEach(cluster => {
                    const count = clusterCounts[cluster];
                    const color = clusterColors[cluster] || clusterColors[0];
                    
                    const item = document.createElement('div');
                    item.className = 'overlay-legend-item';
                    item.innerHTML = `
                        <div class="overlay-legend-color" style="background-color: ${color.main}"></div>
                        <span>Cluster ${cluster} (${count})</span>
                    `;
                    overlayLegend.appendChild(item);
                });
            } else {
                // Show pattern information
                const visibleData = filteredData.filter(d => d.visible);
                const patternCounts = {};
                const patternColorMode = document.getElementById('patternColorMode').value;
                
                visibleData.forEach(d => {
                    const pattern = detectCandlePattern(d);
                    patternCounts[pattern] = (patternCounts[pattern] || 0) + 1;
                });
                
                const sortedPatterns = Object.keys(patternCounts).sort((a, b) => patternCounts[b] - patternCounts[a]);
                
                sortedPatterns.slice(0, 5).forEach(pattern => {
                    const count = patternCounts[pattern];
                    const displayName = pattern.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    
                    let color;
                    if (patternColorMode === 'pattern_specific') {
                        color = getCandlePatternColor(pattern).main;
                    } else if (patternColorMode === 'no_colors') {
                        color = defaultColors.neutral.main;
                    } else {
                        if (pattern.includes('bullish') || pattern === 'hammer' || pattern === 'inverted_hammer') {
                            color = defaultColors.bullish.main;
                        } else if (pattern.includes('bearish') || pattern === 'hanging_man' || pattern === 'shooting_star' || pattern === 'marubozu') {
                            color = defaultColors.bearish.main;
                        } else {
                            color = defaultColors.neutral.main;
                        }
                    }
                    
                    const item = document.createElement('div');
                    item.className = 'overlay-legend-item';
                    item.innerHTML = `
                        <div class="overlay-legend-color" style="background-color: ${color}"></div>
                        <span>${displayName} (${count})</span>
                    `;
                    overlayLegend.appendChild(item);
                });
            }
        }
        
        // Click outside to close settings
        document.addEventListener('click', (e) => {
            const settingsPanel = document.getElementById('overlaySettingsPanel');
            const settingsButton = document.querySelector('.overlay-settings');
            const resetButton = document.querySelector('.overlay-settings[onclick="resetChartToDefault()"]');
            
            if (!settingsPanel.contains(e.target) && !settingsButton.contains(e.target) && !resetButton.contains(e.target)) {
                settingsPanel.classList.add('hidden');
            }
        });
        
        // Interactive chart functions
        function setupInteractiveChart() {
            if (!canvas) {
                console.error('Canvas not found for interactive setup');
                return;
            }
            
            // Mouse events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseenter', handleMouseEnter);
            // Add wheel event listener that only works with modifier keys
            canvas.addEventListener('wheel', (e) => {
                if (e.ctrlKey || e.metaKey || e.shiftKey) {
                    handleWheel(e);
                }
                // Do nothing for normal scroll - allow page scrolling
            });
            canvas.addEventListener('mouseleave', handleMouseLeave);
            
            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);
        }
        
        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            isMouseDown = true;
            isDragging = true;
            lastMouseX = (e.clientX - rect.left) * scaleX;
            lastMouseY = (e.clientY - rect.top) * scaleY;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            canvas.style.cursor = 'grabbing';
        }
        
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;
            
            // Update crosshair (in display coordinates)
            crosshairX = e.clientX - rect.left;
            crosshairY = e.clientY - rect.top;
            
            // Check if hovering over a data point
            const newHoveredIndex = getHoveredDataIndex(mouseX, mouseY);
            const hoverChanged = newHoveredIndex !== hoveredIndex;
            hoveredIndex = newHoveredIndex;
            
            if (isMouseDown && isDragging) {
                // Pan the visible range of the chart
                const deltaX = mouseX - lastMouseX;
                const deltaY = mouseY - lastMouseY;
                
                
                // Use horizontal movement to pan through data range
                if (Math.abs(deltaX) >= 1) { // Only pan if there's actual movement
                    panVisibleRange(deltaX * panningSensitivity);
                }
                
                // Use vertical movement for price panning (optional)
                panOffsetY += deltaY;
                
                lastMouseX = mouseX;
                lastMouseY = mouseY;
                
                updateChart(); // Full update to show new data range
            } else {
                // Update crosshair smoothly
                if (hoverChanged) {
                    redrawChart();
                } else {
                    updateCrosshairSmoothly();
                }
            }
        }
        
        function handleMouseUp(e) {
            isMouseDown = false;
            isDragging = false;
            canvas.style.cursor = 'crosshair';
        }
        
        function handleWheel(e) {
            // Only handle scroll with modifier keys (Ctrl/Shift)
            if (e.ctrlKey || e.metaKey || e.shiftKey) {
                e.preventDefault();
                
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;
                
                // Adjust max visible points with scroll
                const currentMaxPoints = parseInt(document.getElementById('maxVisiblePoints').value);
                const step = 10; // Adjust by 10 points per scroll
                const newMaxPoints = e.deltaY > 0 
                    ? Math.max(10, currentMaxPoints - step) 
                    : Math.min(200, currentMaxPoints + step);
                
                // Update the slider and trigger the update function
                document.getElementById('maxVisiblePoints').value = newMaxPoints;
                updateMaxVisiblePoints();
            }
            // Do not prevent default when no modifier keys - allow normal page scrolling
        }
        
        function handleMouseLeave(e) {
            hoveredIndex = -1;
            crosshairX = -1;
            crosshairY = -1;
            redrawChart();
        }
        
        function handleMouseEnter(e) {
            // Initialize crosshair position when mouse enters canvas
            const rect = canvas.getBoundingClientRect();
            crosshairX = e.clientX - rect.left;
            crosshairY = e.clientY - rect.top;
            redrawChart();
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                lastMouseX = (touch.clientX - rect.left) * scaleX;
                lastMouseY = (touch.clientY - rect.top) * scaleY;
                isMouseDown = true;
                isDragging = true;
            }
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1 && isMouseDown) {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const mouseX = (touch.clientX - rect.left) * scaleX;
                const mouseY = (touch.clientY - rect.top) * scaleY;
                
                const deltaX = mouseX - lastMouseX;
                const deltaY = mouseY - lastMouseY;
                
                panOffsetX += deltaX;
                panOffsetY += deltaY;
                
                lastMouseX = mouseX;
                lastMouseY = mouseY;
                
                redrawChart();
            }
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            isMouseDown = false;
            isDragging = false;
        }
        
        function getHoveredDataIndex(mouseX, mouseY) {
            if (filteredData.length === 0) return -1;
            
            const chartType = document.getElementById('chartType').value;
            const visibleData = filteredData.filter(d => d.visible);
            
            if (visibleData.length === 0) return -1;
            
            // Update visible range if needed
            updateVisibleRange();
            
            // Get the data points to display
            const displayData = visibleData.slice(visibleStartIndex, visibleEndIndex + 1);
            if (displayData.length === 0) return -1;
            
            // Transform mouse coordinates to account for pan only (zoom disabled)
            const transformedX = mouseX - panOffsetX;
            const transformedY = mouseY - panOffsetY;
            
            // Check if mouse is within chart area
            if (transformedX < chartArea.x || transformedX > chartArea.x + chartArea.width ||
                transformedY < chartArea.y || transformedY > chartArea.y + chartArea.height) {
                return -1;
            }
            
            // Calculate data spacing based on visible data
            const dataWidth = chartArea.width / displayData.length;
            const dataIndex = Math.floor((transformedX - chartArea.x) / dataWidth);
            
            if (dataIndex >= 0 && dataIndex < displayData.length) {
                const data = displayData[dataIndex];
                const x = chartArea.x + dataIndex * dataWidth;
                
                // Check if mouse is within the data point bounds
                if (chartType === 'candlestick') {
                    const candleWidth = parseInt(document.getElementById('candleWidth').value);
                    if (Math.abs(transformedX - x) <= candleWidth / 2) {
                        return visibleStartIndex + dataIndex; // Return global index
                    }
                } else {
                    if (Math.abs(transformedX - x) <= dataWidth / 2) {
                        return visibleStartIndex + dataIndex; // Return global index
                    }
                }
            }
            
            return -1;
        }
        
        function drawCrosshair() {
            if (!crosshairEnabled || crosshairX < 0 || crosshairY < 0) return;
            
            // Scale crosshair coordinates to canvas resolution
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const scaledX = crosshairX * scaleX;
            const scaledY = crosshairY * scaleY;
            
            // Check if crosshair is within chart area
            if (scaledX < chartArea.x || scaledX > chartArea.x + chartArea.width ||
                scaledY < chartArea.y || scaledY > chartArea.y + chartArea.height) {
                return;
            }
            
            ctx.save();
            
            // Reset any transformations for crosshair drawing
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            // Enable anti-aliasing for smoother lines
            ctx.imageSmoothingEnabled = true;
            
            // Draw crosshair with better visibility and anti-aliasing
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([6, 3]);
            ctx.lineCap = 'round';
            
            // Vertical line
            ctx.beginPath();
            ctx.moveTo(scaledX + 0.5, chartArea.y);
            ctx.lineTo(scaledX + 0.5, chartArea.y + chartArea.height);
            ctx.stroke();
            
            // Horizontal line
            ctx.beginPath();
            ctx.moveTo(chartArea.x, scaledY + 0.5);
            ctx.lineTo(chartArea.x + chartArea.width, scaledY + 0.5);
            ctx.stroke();
            
            // Draw center dot for better visibility
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.beginPath();
            ctx.arc(scaledX, scaledY, 2.5, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw border around center dot
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.lineWidth = 1;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(scaledX, scaledY, 2.5, 0, 2 * Math.PI);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function drawTooltip() {
            if (hoveredIndex < 0 || filteredData.length === 0) return;
            
            const visibleData = filteredData.filter(d => d.visible);
            if (hoveredIndex >= visibleData.length) return;
            
            const data = visibleData[hoveredIndex];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mouseX = crosshairX * scaleX;
            const mouseY = crosshairY * scaleY;
            
            // Tooltip content
            const tooltipText = [
                `Time: ${new Date(data.timestamp).toLocaleString()}`,
                `Open: ${data.open.toFixed(2)}`,
                `High: ${data.high.toFixed(2)}`,
                `Low: ${data.low.toFixed(2)}`,
                `Close: ${data.close.toFixed(2)}`,
                `Volume: ${data.volume.toLocaleString()}`,
                `Cluster: ${data.predicted_cluster || 0}`
            ];
            
            // Calculate tooltip dimensions
            ctx.font = '12px Arial';
            const lineHeight = 16;
            const padding = 8;
            const maxWidth = Math.max(...tooltipText.map(text => ctx.measureText(text).width));
            const tooltipWidth = maxWidth + padding * 2;
            const tooltipHeight = tooltipText.length * lineHeight + padding * 2;
            
            // Position tooltip
            let tooltipX = mouseX + 10;
            let tooltipY = mouseY - tooltipHeight / 2;
            
            // Keep tooltip within canvas bounds
            if (tooltipX + tooltipWidth > canvas.width) {
                tooltipX = mouseX - tooltipWidth - 10;
            }
            if (tooltipY < 0) {
                tooltipY = 10;
            }
            if (tooltipY + tooltipHeight > canvas.height) {
                tooltipY = canvas.height - tooltipHeight - 10;
            }
            
            // Draw tooltip background
            ctx.save();
            
            // Reset transformations for tooltip
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            // Enable anti-aliasing
            ctx.imageSmoothingEnabled = true;
            
            // Draw tooltip background with rounded corners
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            if (ctx.roundRect) {
                ctx.beginPath();
                ctx.roundRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight, 4);
                ctx.fill();
            } else {
                ctx.fillRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
            }
            
            // Draw tooltip border
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 1;
            if (ctx.roundRect) {
                ctx.beginPath();
                ctx.roundRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight, 4);
                ctx.stroke();
            } else {
                ctx.strokeRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
            }
            
            // Draw tooltip text
            ctx.fillStyle = 'white';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.font = '12px Arial';
            tooltipText.forEach((text, index) => {
                ctx.fillText(text, tooltipX + padding, tooltipY + padding + index * lineHeight);
            });
            
            ctx.restore();
        }
        
        function resetZoom() {
            zoomLevel = 1;
            panOffsetX = 0;
            panOffsetY = 0;
            updateChart();
        }
        
        function resetVisibleRange() {
            const visibleData = filteredData.filter(d => d.visible);
            if (visibleData.length === 0) return;
            
            // Reset to show the most recent data
            visibleEndIndex = visibleData.length - 1;
            visibleStartIndex = Math.max(0, visibleEndIndex - maxVisiblePoints + 1);
            
            updateChart();
        }
        
        function resetChartToDefault() {
            // Reset all chart settings to default values
            resetZoom();
            resetVisibleRange();
            
            // Reset max visible points to default
            document.getElementById('maxVisiblePoints').value = 50;
            updateMaxVisiblePoints();
            
            // Reset panning sensitivity to default
            document.getElementById('panningSensitivity').value = 1.0;
            updatePanningSensitivity();
            
            // Reset panel opacity to default
            document.getElementById('panelOpacity').value = 0.8;
            updatePanelOpacity();
            
            // Reset all panel visibility to default (all visible)
            const panelCheckboxes = [
                'showChartPanel', 'showFiltersPanel', 'showColorsPanel', 
                'showStatsPanel', 'showLegendPanel'
            ];
            panelCheckboxes.forEach(checkboxId => {
                const checkbox = document.getElementById(checkboxId);
                if (checkbox) {
                    checkbox.checked = true;
                }
            });
            updatePanelVisibility();
            
            // Reset minimize state
            const minimizeButtons = document.querySelectorAll('.minimize-btn');
            minimizeButtons.forEach(btn => {
                btn.textContent = '−';
                btn.parentElement.classList.remove('minimized');
            });
            updateMinimizeButtons();
            
            // Reset chart type to default
            document.getElementById('chartType').value = 'candlestick';
            
            // Reset number of rows to default
            document.getElementById('numRows').value = 200;
            
            // Reset candle width to default
            document.getElementById('candleWidth').value = 8;
            
            // Reset cluster filter to all
            document.getElementById('clusterFilter').value = 'all';
            
            // Reset candle type filter to all
            document.getElementById('candleTypeFilter').value = 'all';
            
            // Reset candle pattern filter to all
            document.getElementById('candlePatternFilter').value = 'all';
            
            // Reset cluster colors to show
            document.getElementById('showClusterColors').checked = true;
            
            // Reset pattern color mode to default
            document.getElementById('patternColorMode').value = 'bullish_bearish';
            
            // Clear saved settings
            localStorage.removeItem('chartSettings');
            
            // Update the chart with all reset values
            updateChart();
            updateStats();
            updateLegend();
            
            showStatus('🔄 Chart reset to default settings', 'success');
        }
        
        function saveSettings() {
            const settings = {
                // Chart display settings
                maxVisiblePoints: parseInt(document.getElementById('maxVisiblePoints').value),
                panningSensitivity: parseFloat(document.getElementById('panningSensitivity').value),
                panelOpacity: parseFloat(document.getElementById('panelOpacity').value),
                
                // Panel visibility
                showChartPanel: document.getElementById('showChartPanel').checked,
                showFiltersPanel: document.getElementById('showFiltersPanel').checked,
                showColorsPanel: document.getElementById('showColorsPanel').checked,
                showStatsPanel: document.getElementById('showStatsPanel').checked,
                showLegendPanel: document.getElementById('showLegendPanel').checked,
                
                // Chart configuration
                chartType: document.getElementById('chartType').value,
                numRows: parseInt(document.getElementById('numRows').value),
                candleWidth: parseInt(document.getElementById('candleWidth').value),
                
                // Filters
                clusterFilter: document.getElementById('clusterFilter').value,
                candleTypeFilter: document.getElementById('candleTypeFilter').value,
                candlePatternFilter: document.getElementById('candlePatternFilter').value,
                showClusterColors: document.getElementById('showClusterColors').checked,
                patternColorMode: document.getElementById('patternColorMode').value,
                
                // Chart state
                zoomLevel: zoomLevel,
                panOffsetX: panOffsetX,
                panOffsetY: panOffsetY,
                visibleStartIndex: visibleStartIndex,
                visibleEndIndex: visibleEndIndex,
                crosshairEnabled: crosshairEnabled
            };
            
            localStorage.setItem('chartSettings', JSON.stringify(settings));
            // Save silently without notification
        }
        
        function loadSettings() {
            const savedSettings = localStorage.getItem('chartSettings');
            if (!savedSettings) return false;
            
            try {
                const settings = JSON.parse(savedSettings);
                
                // Load chart display settings
                if (settings.maxVisiblePoints) {
                    document.getElementById('maxVisiblePoints').value = settings.maxVisiblePoints;
                    updateMaxVisiblePoints();
                }
                
                if (settings.panningSensitivity) {
                    document.getElementById('panningSensitivity').value = settings.panningSensitivity;
                    updatePanningSensitivity();
                }
                
                if (settings.panelOpacity) {
                    document.getElementById('panelOpacity').value = settings.panelOpacity;
                    updatePanelOpacity();
                }
                
                // Load panel visibility
                const panelCheckboxes = [
                    'showChartPanel', 'showFiltersPanel', 'showColorsPanel', 
                    'showStatsPanel', 'showLegendPanel'
                ];
                panelCheckboxes.forEach(checkboxId => {
                    const checkbox = document.getElementById(checkboxId);
                    if (checkbox && settings[checkboxId] !== undefined) {
                        checkbox.checked = settings[checkboxId];
                    }
                });
                updatePanelVisibility();
                
                // Load chart configuration
                if (settings.chartType) {
                    document.getElementById('chartType').value = settings.chartType;
                }
                
                if (settings.numRows) {
                    document.getElementById('numRows').value = settings.numRows;
                }
                
                if (settings.candleWidth) {
                    document.getElementById('candleWidth').value = settings.candleWidth;
                }
                
                // Load filters
                if (settings.clusterFilter) {
                    document.getElementById('clusterFilter').value = settings.clusterFilter;
                }
                
                if (settings.candleTypeFilter) {
                    document.getElementById('candleTypeFilter').value = settings.candleTypeFilter;
                }
                
                if (settings.candlePatternFilter) {
                    document.getElementById('candlePatternFilter').value = settings.candlePatternFilter;
                }
                
                if (settings.showClusterColors !== undefined) {
                    document.getElementById('showClusterColors').checked = settings.showClusterColors;
                }
                
                if (settings.patternColorMode) {
                    document.getElementById('patternColorMode').value = settings.patternColorMode;
                }
                
                // Load chart state
                if (settings.zoomLevel) {
                    zoomLevel = settings.zoomLevel;
                }
                
                if (settings.panOffsetX !== undefined) {
                    panOffsetX = settings.panOffsetX;
                }
                
                if (settings.panOffsetY !== undefined) {
                    panOffsetY = settings.panOffsetY;
                }
                
                if (settings.visibleStartIndex !== undefined) {
                    visibleStartIndex = settings.visibleStartIndex;
                }
                
                if (settings.visibleEndIndex !== undefined) {
                    visibleEndIndex = settings.visibleEndIndex;
                }
                
                if (settings.crosshairEnabled !== undefined) {
                    crosshairEnabled = settings.crosshairEnabled;
                }
                
                return true;
            } catch (error) {
                console.error('Error loading settings:', error);
                return false;
            }
        }
        
        function clearSettings() {
            localStorage.removeItem('chartSettings');
            showStatus('🗑️ Settings cleared from localStorage', 'success');
        }
        
        function toggleCrosshair() {
            crosshairEnabled = !crosshairEnabled;
            if (crosshairEnabled) {
                showStatus('🎯 Crosshair enabled', 'success');
            } else {
                showStatus('🎯 Crosshair disabled', 'info');
            }
            redrawChart();
        }
        
        function updateCrosshairSmoothly() {
            if (crosshairAnimationFrame) {
                cancelAnimationFrame(crosshairAnimationFrame);
            }
            
            crosshairAnimationFrame = requestAnimationFrame(() => {
                if (Math.abs(crosshairX - lastCrosshairX) > 1 || Math.abs(crosshairY - lastCrosshairY) > 1) {
                    redrawChart();
                    lastCrosshairX = crosshairX;
                    lastCrosshairY = crosshairY;
                }
                crosshairAnimationFrame = null;
            });
        }
        
        function saveSettingsWithNotification() {
            saveSettings();
            showStatus('💾 Settings saved to localStorage', 'success');
        }
        
        function panToMiddle() {
            const visibleData = filteredData.filter(d => d.visible);
            if (visibleData.length === 0) return;
            
            // Pan to the middle of the dataset
            const middleIndex = Math.floor(visibleData.length / 2);
            panToPosition(middleIndex);
            updateChart();
        }
        
        function initializeVisibleRange() {
            const visibleData = filteredData.filter(d => d.visible);
            if (visibleData.length === 0) return;
            
            // Initialize visible range to show the last maxVisiblePoints
            visibleEndIndex = visibleData.length - 1;
            visibleStartIndex = Math.max(0, visibleEndIndex - maxVisiblePoints + 1);
            
            // Ensure we don't exceed the available data
            if (visibleEndIndex >= visibleData.length) {
                visibleEndIndex = visibleData.length - 1;
                visibleStartIndex = Math.max(0, visibleEndIndex - maxVisiblePoints + 1);
            }
            
            // If we have more data than maxVisiblePoints, ensure we can pan through all of it
            if (visibleData.length > maxVisiblePoints) {
                // Start from the most recent data but allow panning through all
                visibleEndIndex = visibleData.length - 1;
                visibleStartIndex = Math.max(0, visibleEndIndex - maxVisiblePoints + 1);
            }
            
        }
        
        function updateVisibleRange() {
            const visibleData = filteredData.filter(d => d.visible);
            if (visibleData.length === 0) return;
            
            // Use maxVisiblePoints directly without zoom level adjustment
            const adjustedMaxPoints = maxVisiblePoints;
            
            // Ensure visible range is within bounds
            visibleStartIndex = Math.max(0, Math.min(visibleStartIndex, visibleData.length - 1));
            visibleEndIndex = Math.max(visibleStartIndex, Math.min(visibleEndIndex, visibleData.length - 1));
            
            // Ensure we don't exceed the available data
            if (visibleEndIndex - visibleStartIndex + 1 > adjustedMaxPoints) {
                visibleEndIndex = visibleStartIndex + adjustedMaxPoints - 1;
            }
            
            // Ensure we don't go beyond available data
            if (visibleEndIndex >= visibleData.length) {
                visibleEndIndex = visibleData.length - 1;
                visibleStartIndex = Math.max(0, visibleEndIndex - adjustedMaxPoints + 1);
            }
        }
        
        function panVisibleRange(deltaX) {
            const visibleData = filteredData.filter(d => d.visible);
            if (visibleData.length === 0) return;
            
            // Calculate how many data points to move based on drag distance
            const dataWidth = chartArea.width / (visibleEndIndex - visibleStartIndex + 1);
            const pointsToMove = Math.round(deltaX / dataWidth);
            
            // Reduce sensitivity - only move if there's significant drag
            if (Math.abs(pointsToMove) < 0.5) return; // Ignore tiny movements
            
            // Calculate the range size
            const rangeSize = visibleEndIndex - visibleStartIndex + 1;
            
            // Update visible range - drag right moves to more recent data (higher indices)
            const newStartIndex = Math.max(0, visibleStartIndex + pointsToMove);
            const newEndIndex = Math.min(visibleData.length - 1, newStartIndex + rangeSize - 1);
            
            // Ensure we don't go beyond available data
            if (newEndIndex >= visibleData.length) {
                const adjustedEndIndex = visibleData.length - 1;
                const adjustedStartIndex = Math.max(0, adjustedEndIndex - rangeSize + 1);
                visibleStartIndex = adjustedStartIndex;
                visibleEndIndex = adjustedEndIndex;
            } else if (newStartIndex < 0) {
                visibleStartIndex = 0;
                visibleEndIndex = Math.min(visibleData.length - 1, rangeSize - 1);
            } else {
                visibleStartIndex = newStartIndex;
                visibleEndIndex = newEndIndex;
            }
            
        }
        
        function panToPosition(startIndex) {
            const visibleData = filteredData.filter(d => d.visible);
            if (visibleData.length === 0) return;
            
            const rangeSize = visibleEndIndex - visibleStartIndex + 1;
            const newStartIndex = Math.max(0, Math.min(startIndex, visibleData.length - rangeSize));
            const newEndIndex = Math.min(visibleData.length - 1, newStartIndex + rangeSize - 1);
            
            visibleStartIndex = newStartIndex;
            visibleEndIndex = newEndIndex;
            
        }
        
        function updateMaxVisiblePoints() {
            const slider = document.getElementById('maxVisiblePoints');
            const valueDisplay = document.getElementById('maxVisiblePointsValue');
            
            maxVisiblePoints = parseInt(slider.value);
            valueDisplay.textContent = maxVisiblePoints;
            
            // Recalculate visible range with new max points
            const visibleData = filteredData.filter(d => d.visible);
            if (visibleData.length === 0) return;
            
            // Use maxVisiblePoints directly without zoom level adjustment
            const adjustedMaxPoints = maxVisiblePoints;
            
            // Keep the current end index but adjust start index to fit new max points
            const currentRangeSize = visibleEndIndex - visibleStartIndex + 1;
            const newRangeSize = Math.min(adjustedMaxPoints, visibleData.length);
            
            if (newRangeSize < currentRangeSize) {
                // Shrink the range from the start
                visibleStartIndex = Math.max(0, visibleEndIndex - newRangeSize + 1);
            } else if (newRangeSize > currentRangeSize) {
                // Expand the range from the start
                visibleStartIndex = Math.max(0, visibleEndIndex - newRangeSize + 1);
            }
            
            // Ensure we don't go beyond available data
            if (visibleEndIndex >= visibleData.length) {
                visibleEndIndex = visibleData.length - 1;
                visibleStartIndex = Math.max(0, visibleEndIndex - newRangeSize + 1);
            }
            
            
            updateChart();
            
            // Auto-save settings
            saveSettings();
        }
        
        function updatePanningSensitivity() {
            const slider = document.getElementById('panningSensitivity');
            const valueDisplay = document.getElementById('panningSensitivityValue');
            
            if (slider && valueDisplay) {
                panningSensitivity = parseFloat(slider.value);
                valueDisplay.textContent = panningSensitivity.toFixed(1);
                
                // Auto-save settings
                saveSettings();
            }
        }
        
        function adjustPanningSensitivity(delta) {
            const slider = document.getElementById('panningSensitivity');
            const valueDisplay = document.getElementById('panningSensitivityValue');
            
            if (slider && valueDisplay) {
                const newValue = Math.max(0.1, Math.min(5.0, panningSensitivity + delta));
                slider.value = newValue;
                panningSensitivity = newValue;
                valueDisplay.textContent = panningSensitivity.toFixed(1);
                
                // Auto-save settings
                saveSettings();
            }
        }
        
        function adjustMaxVisiblePoints(delta) {
            const slider = document.getElementById('maxVisiblePoints');
            const valueDisplay = document.getElementById('maxVisiblePointsValue');
            
            if (slider && valueDisplay) {
                const currentValue = parseInt(slider.value);
                const newValue = Math.max(10, Math.min(200, currentValue + delta));
                slider.value = newValue;
                updateMaxVisiblePoints();
                // Auto-save is handled in updateMaxVisiblePoints
            }
        }
        
        function debugChart() {
            console.log('Chart Debug Info:');
            console.log('Total data:', stockData.length);
            console.log('Filtered data:', filteredData.length);
            console.log('Visible data:', filteredData.filter(d => d.visible).length);
            console.log('Visible range:', visibleStartIndex, 'to', visibleEndIndex);
            console.log('Max visible points:', maxVisiblePoints);
            console.log('Zoom level:', zoomLevel);
            console.log('Pan offset:', panOffsetX, panOffsetY);
            console.log('Chart area:', chartArea);
            console.log('Canvas size:', canvas.width, canvas.height);
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
        
        // Handle window resize
        window.addEventListener('resize', () => {
            setupCanvas();
            updateChart();
        });
        
        // Handle keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Only handle shortcuts when not typing in input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            switch(e.key) {
                case '1':
                    setMaxVisiblePoints(20);
                    break;
                case '2':
                    setMaxVisiblePoints(50);
                    break;
                case '3':
                    setMaxVisiblePoints(100);
                    break;
                case '4':
                    setMaxVisiblePoints(200);
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    panVisibleRange(-10); // Pan left (to older data)
                    updateChart();
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    panVisibleRange(10); // Pan right (to newer data)
                    updateChart();
                    break;
                case 'Home':
                    e.preventDefault();
                    resetVisibleRange(); // Go to latest data
                    break;
                case 'End':
                    e.preventDefault();
                    // Go to earliest data
                    const visibleData = filteredData.filter(d => d.visible);
                    if (visibleData.length > 0) {
                        visibleStartIndex = 0;
                        visibleEndIndex = Math.min(maxVisiblePoints - 1, visibleData.length - 1);
                        updateChart();
                    }
                    break;
                case '+':
                case '=':
                    e.preventDefault();
                    adjustPanningSensitivity(0.1);
                    break;
                case '-':
                    e.preventDefault();
                    adjustPanningSensitivity(-0.1);
                    break;
                case 'PageUp':
                    e.preventDefault();
                    adjustMaxVisiblePoints(10);
                    break;
                case 'PageDown':
                    e.preventDefault();
                    adjustMaxVisiblePoints(-10);
                    break;
                case 'r':
                case 'R':
                    e.preventDefault();
                    resetChartToDefault();
                    break;
                case 'c':
                case 'C':
                    e.preventDefault();
                    toggleCrosshair();
                    break;
            }
        });
        
        function setMaxVisiblePoints(value) {
            const slider = document.getElementById('maxVisiblePoints');
            const valueDisplay = document.getElementById('maxVisiblePointsValue');
            
            slider.value = value;
            maxVisiblePoints = value;
            valueDisplay.textContent = value;
            
            // Recalculate visible range with new max points
            const visibleData = filteredData.filter(d => d.visible);
            if (visibleData.length === 0) return;
            
            // Use maxVisiblePoints directly without zoom level adjustment
            const adjustedMaxPoints = maxVisiblePoints;
            
            // Keep the current end index but adjust start index to fit new max points
            const currentRangeSize = visibleEndIndex - visibleStartIndex + 1;
            const newRangeSize = Math.min(adjustedMaxPoints, visibleData.length);
            
            if (newRangeSize < currentRangeSize) {
                // Shrink the range from the start
                visibleStartIndex = Math.max(0, visibleEndIndex - newRangeSize + 1);
            } else if (newRangeSize > currentRangeSize) {
                // Expand the range from the start
                visibleStartIndex = Math.max(0, visibleEndIndex - newRangeSize + 1);
            }
            
            // Ensure we don't go beyond available data
            if (visibleEndIndex >= visibleData.length) {
                visibleEndIndex = visibleData.length - 1;
                visibleStartIndex = Math.max(0, visibleEndIndex - newRangeSize + 1);
            }
            
            
            updateChart();
        }
    </script>
</body>
</html>